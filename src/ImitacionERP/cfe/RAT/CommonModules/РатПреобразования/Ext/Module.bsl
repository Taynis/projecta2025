//©///////////////////////////////////////////////////////////////////////////©//
//
//  Copyright 2021-2025 BIA-Technologies Limited Liability Company
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
//©///////////////////////////////////////////////////////////////////////////©//

#Область ПрограммныйИнтерфейс

// Преобразует прикладной объект в примитивный тип для сериализации в JSON.
//
// Параметры:
//   Значение - Произвольный - значение, которое необходимо сериализовать в JSON
//
// Возвращаемое значение:
//   Произвольный, Неопределено - значение, готовое для сериализации в JSON
//
// Пример:
//   СериализованноеЗначение = РатПреобразования.СериализоватьЗначение(Дата(2024, 1, 15));
//   // Результат: "2024-01-15T00:00:00"
Функция СериализоватьЗначение(Значение) Экспорт
	
	ТипЗначения = ТипЗнч(Значение);
	
	Результат = Неопределено;
	
	Если Значение = Неопределено ИЛИ Значение = Null Тогда
		
		Результат = Неопределено;
		
	ИначеЕсли РатJSON.ЭтоПримитивныйТипJSON(ТипЗначения) Тогда
		
		Результат = Значение;
		
	ИначеЕсли РатТипыДанных.ЭтоСсылочныйТип(ТипЗначения) Тогда
		
		Результат = РатПреобразованияСсылки.СериализоватьСсылку(Значение, ТипЗначения);
	
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		
		Результат = XMLСтрока(Значение);
		
	ИначеЕсли ТипЗначения = Тип("Массив") Тогда
		
		Результат = РатПреобразованияКоллекции.СериализоватьМассив(Значение);
		 
	ИначеЕсли ТипЗначения = Тип("СписокЗначений") Тогда
		
		Результат = РатПреобразованияКоллекции.СериализоватьСписокЗначений(Значение);
		 
	ИначеЕсли РатТипыДанных.ЭтоСтруктура(Значение) ИЛИ ТипЗначения = Тип("Соответствие") Тогда
		
		Результат = РатПреобразованияКоллекции.СериализоватьСтруктуру(Значение, ТипЗначения);
		
	ИначеЕсли ТипЗначения = Тип("ТаблицаЗначений") Тогда
		
		Результат = РатПреобразованияКоллекции.СериализоватьТаблицу(Значение);
		
	ИначеЕсли ТипЗначения = Тип("УникальныйИдентификатор") Тогда
		
		Результат = Строка(Значение);
		
	ИначеЕсли ТипЗначения = Тип("ХранилищеЗначения") Тогда
		
		Результат = "<Сериализация не поддерживается>";
		
	ИначеЕсли РатМетаданные.ЭтоТипКлючаЗаписи(ТипЗначения) Тогда
		
		Результат = РатПреобразованияКлючиЗаписи.СериализоватьКлючЗаписи(Значение, ТипЗначения);
		
	ИначеЕсли РатТипыДанных.ЭтоСистемноеПеречисление(ТипЗначения) Тогда
		
		Результат = РатПреобразованияСистемныеПеречисления.КлючСистемногоПеречисления(Значение);
		
	Иначе
		
		Попытка
			
			Результат = XMLСтрока(Значение);
			
		Исключение
			
			Сообщение = СтрШаблон("Не поддерживается возврат значений типа '%1'.", ТипЗначения);
			ВызватьИсключение РатОбщийКлиентСервер.ТекстОшибки(ИнформацияОбОшибке(), Сообщение);
			
		КонецПопытки;
		
	КонецЕсли;
	
	//@skip-check constructor-function-return-section
	Возврат Результат;
	
КонецФункции

// Возвращает значение прикладного типа, полученное из его примитивного представления.
//
// Параметры:
//   Значение - Произвольный - значение примитивного типа, полученное из запроса
//   ОписаниеТипа - Тип, ОписаниеТипов - ожидаемый тип значения
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//   Описание - Строка - описание десериализуемого значения для логирования ошибок
//
// Возвращаемое значение:
//   Произвольный - преобразованное значение
//
// Пример:
//   СтатусОбработкиЗапроса = РатОбщий.НовыйСтатусОбработкиЗапроса();
//   Значение = РатПреобразования.ДесериализоватьЗначение("2024-01-15T12:30:00", 
//       Тип("Дата"), СтатусОбработкиЗапроса, "дата создания");
//   // Результат: 15.01.2024 12:30:00 
Функция ДесериализоватьЗначение(Значение, Знач ОписаниеТипа, СтатусОбработкиЗапроса, Описание) Экспорт
	
	ПараметрыДесериализации = РатПреобразованияВспомогательные.ПараметрыДесериализации(Значение, ОписаниеТипа);
	
	СтатусОбработкиЗапроса.ВложеннаяОперацияУспешна = Истина;
	
	Если ПараметрыДесериализации.ОграничениеТипа = Неопределено Тогда
		
		ТекстОшибки = "В метод должно придти описание типов, но что то пошло не так";
		КлассОшибки = РатОбщий.КлассыОшибок().Неизвестная;
		РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассОшибки, ТекстОшибки);
		
	ИначеЕсли ПараметрыДесериализации.ЭтоВыражение Тогда
		
		Результат = РатАлгоритмы.ВычислитьВыражение(ПараметрыДесериализации.Значение);
		Результат = ПараметрыДесериализации.ОграничениеТипа.ПривестиЗначение(Результат);
		
	ИначеЕсли ПараметрыДесериализации.ТипЗначения = ПараметрыДесериализации.ОжидаемыйТип Тогда
		
		Если ПараметрыДесериализации.ЭтоТипизированнаяСтрока Тогда
			Результат = ПараметрыДесериализации.ПереданноеЗначение;
		Иначе
			Результат = ПараметрыДесериализации.Значение;
		КонецЕсли;
		
	ИначеЕсли ЗначениеЗаполнено(ПараметрыДесериализации.ПредставлениеТипа) Тогда
		
		Результат = РатПреобразованияСсылки.ДесериализоватьРеквизитСоставногоТипа(ПараметрыДесериализации.Значение,
																				  ПараметрыДесериализации,
																				  СтатусОбработкиЗапроса);
		
	ИначеЕсли ПараметрыДесериализации.ЭтоСоставнойТип И РатТипыДанных.ЭтоНеопределено(ПараметрыДесериализации.Значение) Тогда
		
		Результат = Неопределено;
		
	ИначеЕсли ПараметрыДесериализации.ЭтоСоставнойТип
		И ПараметрыДесериализации.ОграничениеТипа.СодержитТип(ПараметрыДесериализации.ТипЗначения) Тогда
		
		Результат = ПараметрыДесериализации.Значение;
		
	ИначеЕсли ПараметрыДесериализации.ЭтоСоставнойТип Тогда
		
		ТекстОшибки = "Реквизит имеет составной тип. Значение необходимо передавать с описание типа
			|Либо в виде структуры с реквизитами type и id или строкой [ТипМетаданных].[ВидМетаданных].[Идентификатор]";
		КлассОшибки = РатОбщий.КлассыОшибок().АнализПараметровЗапроса;
		РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассОшибки, ТекстОшибки);
		
	Иначе
		
		Результат = ПривестиЗначениеКТипу(ПараметрыДесериализации, СтатусОбработкиЗапроса);
		
	КонецЕсли;
	
	Если НЕ СтатусОбработкиЗапроса.ВложеннаяОперацияУспешна Тогда
		
		ТекстОшибки = "Не удалось вычислить " + Описание;
		КлассОшибки = РатОбщий.КлассыОшибок().РазборПараметровЗапроса;
		РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассОшибки, ТекстОшибки);
		
	ИначеЕсли ЗначениеЗаполнено(ПараметрыДесериализации.ОграничениеТипа) Тогда
		
		Возврат ПараметрыДесериализации.ОграничениеТипа.ПривестиЗначение(Результат);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Десериализует массив значений в соответствии с ожидаемым типом.
//
// Параметры:
//   Значения - Массив из Произвольный - массив значений для десериализации
//   ОжидаемыйТипЗначения - Тип, ОписаниеТипов - ожидаемый тип элементов массива
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//   Описание - Строка - описание десериализуемого массива для логирования ошибок
//
// Возвращаемое значение:
//   Массив из Произвольный - массив десериализованных значений
//
// Пример:
//   СтатусОбработкиЗапроса = РатОбщий.НовыйСтатусОбработкиЗапроса();
//   Значения = РатПреобразования.ДесериализоватьМассивЗначений(
//       Новый Массив("2024-01-15", "2024-01-16"), Тип("Дата"), 
//       СтатусОбработкиЗапроса, "массив дат");
//
Функция ДесериализоватьМассивЗначений(Значения, Знач ОжидаемыйТипЗначения, СтатусОбработкиЗапроса, Описание) Экспорт
	
	Результат = Новый Массив();
	
	Для Каждого ПереданноеЗначение Из Значения Цикл
		
		Значение = ДесериализоватьЗначение(ПереданноеЗначение, ОжидаемыйТипЗначения, СтатусОбработкиЗапроса, Описание);
		
		Если СтатусОбработкиЗапроса.Успешно Тогда
			Результат.Добавить(Значение);
		Иначе
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#Область ПреобразованиеПоОписанию

// Преобразует структуру данных в соответствии с описанием реквизитов.
//
// Параметры:
//   Данные - Структура - данные, полученные из запроса
//   ОписаниеРеквизитов - Массив из см. РатПреобразования.ОписаниеРеквизита - описание реквизитов для преобразования
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//   Описание - Строка - описание преобразуемых данных для логирования ошибок
//
// Возвращаемое значение:
//   Структура, Неопределено - преобразованные данные
//
// Пример:
//   ОписаниеРеквизитов = Новый Массив;
//   ОписаниеРеквизитов.Добавить(РатПреобразования.ОписаниеРеквизита("Имя", Тип("Строка")));
//   Результат = РатПреобразования.ПреобразоватьДанные(Данные, ОписаниеРеквизитов, 
//       СтатусОбработкиЗапроса, "данные пользователя");
Функция ПреобразоватьДанные(Данные, ОписаниеРеквизитов, СтатусОбработкиЗапроса, Описание) Экспорт
	
	Если НЕ СтатусОбработкиЗапроса.Успешно Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Структура;
	
	Псевдонимы = Новый Соответствие();
	
	Для Каждого ОписаниеРеквизита Из ОписаниеРеквизитов Цикл
		
		Псевдонимы.Вставить(НРег(ОписаниеРеквизита.Имя), ОписаниеРеквизита);
		
		Если НЕ ЗначениеЗаполнено(ОписаниеРеквизита.Псевдонимы) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого Псевдоним Из ОписаниеРеквизита.Псевдонимы Цикл
			Псевдонимы.Вставить(НРег(Псевдоним), ОписаниеРеквизита);
		КонецЦикла;
		
	КонецЦикла;
	
	КлассыОшибок = РатОбщий.КлассыОшибок();
	
	Успешно = Истина;
	
	НормализованныеДанные = Новый Структура;
	
	Для Каждого Элемент Из Данные Цикл
		
		ОписаниеРеквизита = Псевдонимы[НРег(Элемент.Ключ)];
		
		Если ОписаниеРеквизита = Неопределено Тогда
			
			Текст = СтрШаблон("Неизвестный реквизит %1, %2", Элемент.Ключ, Описание);
			РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассыОшибок.АнализПараметровЗапроса, Текст);
			Успешно = Ложь;
			
		ИначеЕсли НормализованныеДанные.Свойство(ОписаниеРеквизита.Имя) Тогда
			
			Текст = СтрШаблон("Обнаружено дублирование данных, данные с ключем '%1' уже присутствуют. Возможно не верно описаны данные.
			|%2", Элемент.Ключ, Описание);
			РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассыОшибок.АнализПараметровЗапроса, Текст);
			Успешно = Ложь;
			
		Иначе
			
			НормализованныеДанные.Вставить(ОписаниеРеквизита.Имя, Элемент.Значение);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если НЕ Успешно Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого ОписаниеРеквизита Из ОписаниеРеквизитов Цикл
		
		Если НЕ НормализованныеДанные.Свойство(ОписаниеРеквизита.Имя) Тогда
			
			Если ОписаниеРеквизита.ЗначениеПоУмолчанию <> Неопределено Тогда
				Результат.Вставить(ОписаниеРеквизита.Имя, ОписаниеРеквизита.ЗначениеПоУмолчанию);
			КонецЕсли;
			
			Продолжить;
			
		КонецЕсли;
		
		СыроеЗначение = НормализованныеДанные[ОписаниеРеквизита.Имя];
		
		ОписаниеДляРеквизита = Описание + СтрШаблон(". Реквизит '%1'", ОписаниеРеквизита.Имя);
		Значение = ПреобразованноеЗначение(СыроеЗначение, ОписаниеРеквизита, СтатусОбработкиЗапроса, ОписаниеДляРеквизита);
		
		Результат.Вставить(ОписаниеРеквизита.Имя, Значение);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Создает описание реквизита для преобразования и проверки данных.
//
// Параметры:
//   Имя - Строка - имя реквизита
//   Тип - Тип - тип реквизита в контексте 1С
//   ЗначениеПоУмолчанию - Произвольный - значение по умолчанию для незаполненных полей
//   Обязательное - Булево - признак обязательного наличия реквизита
//
// Возвращаемое значение:
//   Структура - описание реквизита со свойствами:
//     * Имя - Строка - имя реквизита
//     * Тип - Тип - тип реквизита
//     * ЗначениеПоУмолчанию - Произвольный - значение по умолчанию
//     * Обязательное - Булево - признак обязательности
//     * ВложенныеРеквизиты - Массив из см. ОписаниеРеквизита, Неопределено - описание вложенных реквизитов
//     * ДопустимыеЗначения - Массив из Произвольный, Неопределено - допустимые значения
//     * Псевдонимы - Массив из Строка, Неопределено - псевдонимы реквизита
//
// Пример:
//   Описание = РатПреобразования.ОписаниеРеквизита("Имя", Тип("Строка"), "По умолчанию", Истина);
Функция ОписаниеРеквизита(Имя, Тип, ЗначениеПоУмолчанию = Неопределено, Обязательное = Ложь) Экспорт
	
	Описание = Новый Структура("ВложенныеРеквизиты, ДопустимыеЗначения, Псевдонимы");
	Описание.Вставить("Имя", Имя);
	Описание.Вставить("Тип", Тип);
	Описание.Вставить("ЗначениеПоУмолчанию", ЗначениеПоУмолчанию);
	Описание.Вставить("Обязательное", Обязательное);
	
	//@skip-check constructor-function-return-section
	Возврат Описание;
	
КонецФункции

// Создает описание реквизита коллекции для преобразования и проверки данных.
//
// Параметры:
//   Имя - Строка - имя реквизита коллекции
//   ТипКоллекции - Тип - тип коллекции в контексте 1С
//   ТипЭлемента - Тип - тип элемента коллекции в контексте 1С
//   ЗначениеПоУмолчанию - Произвольный - значение по умолчанию для незаполненных полей
//   Обязательное - Булево - признак обязательного наличия реквизита
//   РеквизитыЭлемента - Массив из см.ОписаниеРеквизита, Неопределено - описание реквизитов элемента коллекции
//
// Возвращаемое значение:
//   Структура - описание коллекции со свойствами:
//     * Имя - Строка - имя реквизита
//     * Тип - Тип - тип коллекции
//     * ТипЭлемента - Тип - тип элемента коллекции
//     * ЗначениеПоУмолчанию - Произвольный - значение по умолчанию
//     * Обязательное - Булево - признак обязательности
//     * РеквизитыЭлемента - Массив из см.ОписаниеРеквизита  - описание реквизитов элемента
//     * Псевдонимы - Массив  из Строка - псевдонимы реквизита
//
// Пример:
//   Описание = РатПреобразования.ОписаниеКоллекции("Товары", Тип("Массив"), 
//       Тип("Строка"), Неопределено, Истина);
Функция ОписаниеКоллекции(Имя,
						  ТипКоллекции,
						  ТипЭлемента,
						  ЗначениеПоУмолчанию = Неопределено,
						  Обязательное = Ложь,
						  РеквизитыЭлемента = Неопределено) Экспорт
	
	Описание = Новый Структура;
	Описание.Вставить("Имя", Имя);
	Описание.Вставить("Тип", ТипКоллекции);
	Описание.Вставить("ТипЭлемента", ТипЭлемента);
	Описание.Вставить("РеквизитыЭлемента", РеквизитыЭлемента);
	Описание.Вставить("Обязательное", Обязательное);
	Описание.Вставить("ЗначениеПоУмолчанию", ЗначениеПоУмолчанию);
	Описание.Вставить("Псевдонимы");
	
	//@skip-check constructor-function-return-section
	Возврат Описание;
	
КонецФункции

// Создает описание реквизитов на основе коллекции реквизитов метаданных.
//
// Параметры:
//   КоллекцияРеквизитов - КоллекцияОбъектовМетаданных, Массив из ОбъектМетаданных - коллекция реквизитов метаданных
//
// Возвращаемое значение:
//   Массив из см. РатПреобразования.ОписаниеРеквизита - коллекция описаний реквизитов
//
// Пример:
//   Реквизиты = РатПреобразования.ОписаниеРеквизитовОбъектаМетаданных(
//       Метаданные.Справочники.Контрагенты.Реквизиты);
Функция ОписаниеРеквизитовОбъектаМетаданных(КоллекцияРеквизитов) Экспорт
	
	ОписаниеРеквизитов = Новый Массив;
	
	Для Каждого Реквизит Из КоллекцияРеквизитов Цикл
		
		ОписаниеРеквизитов.Добавить(ОписаниеРеквизита(Реквизит.Имя, Реквизит.Тип));
		
	КонецЦикла;
	
	Возврат ОписаниеРеквизитов;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Извлекает данные сохраняемого объекта из тела запроса.
//
// Параметры:
//   ТелоЗапроса - Структура - тело HTTP-запроса с данными объекта
//   ИмяТаблицы - Строка - имя таблицы для сохранения данных
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//
// Возвращаемое значение:
//   Структура, Неопределено - данные записи со свойствами:
//     * Реквизиты - Структура - реквизиты объекта
//     * ТабличныеЧасти - Структура - табличные части объекта
//     * Данные - Массив из Произвольный - данные для регистров
//     * ДополнительныеСвойства - Структура - дополнительные свойства
//     * ДополнительныеПараметры - Структура - дополнительные параметры
//     * Параметры - Структура - параметры записи
//
Функция ДанныеСохраняемогоОбъекта(ТелоЗапроса, ИмяТаблицы, СтатусОбработкиЗапроса) Экспорт
	
	Если НЕ СтатусОбработкиЗапроса.Успешно Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	КлючПараметрыЗаписи = "writeSettings";
	ДанныеЗаписи = РатИнформационнаяБаза.ДанныеЗаписи(ИмяТаблицы);
	
	Если РатКоллекции.ЗначениеСтруктуры(ТелоЗапроса, "data") <> Неопределено Тогда
		ИзвлечьДанныеОбъекта(ДанныеЗаписи, ТелоЗапроса.data, ИмяТаблицы, СтатусОбработкиЗапроса);
	КонецЕсли;
	
	Если РатКоллекции.ЗначениеСтруктуры(ТелоЗапроса, "additionalProperties") <> Неопределено Тогда
		РатКоллекции.ОбъединитьВСтруктуру(ДанныеЗаписи.ДополнительныеСвойства, ТелоЗапроса.additionalProperties);
	КонецЕсли;
	
	Если РатКоллекции.ЗначениеСтруктуры(ТелоЗапроса, "additionalParameters") <> Неопределено Тогда
		РатКоллекции.ОбъединитьВСтруктуру(ДанныеЗаписи.ДополнительныеПараметры, ТелоЗапроса.additionalParameters);
	КонецЕсли;
	
	Если РатКоллекции.ЗначениеСтруктуры(ТелоЗапроса, КлючПараметрыЗаписи) <> Неопределено Тогда
		
		НастройкиПреобразования = СхемаНастроекЗаписи();
		
		ПараметрыЗаписи = ПреобразоватьДанные(ТелоЗапроса[КлючПараметрыЗаписи], НастройкиПреобразования, СтатусОбработкиЗапроса, КлючПараметрыЗаписи);
		РатКоллекции.ОбъединитьВСтруктуру(ДанныеЗаписи.Параметры, ПараметрыЗаписи);
		
	КонецЕсли;
	
	//@skip-check constructor-function-return-section
	Возврат ДанныеЗаписи;
	
КонецФункции

// Извлекает и десериализует идентификатор записи из параметров запроса.
//
// Параметры:
//   ПараметрыЗапроса - Структура - параметры HTTP-запроса
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//   РеквизитИдентификатор - Строка - имя реквизита с идентификатором (по умолчанию "Идентификатор")
//
// Возвращаемое значение:
//   Произвольный - десериализованный идентификатор записи (ссылка или ключ записи)
//
Функция ИдентификаторЗаписи(ПараметрыЗапроса, СтатусОбработкиЗапроса, РеквизитИдентификатор = "Идентификатор") Экспорт
	
	Результат = Неопределено;
	
	Если НЕ СтатусОбработкиЗапроса.Успешно Тогда
		Возврат Результат;
	КонецЕсли;
	
	Идентификатор = ПараметрыЗапроса[РеквизитИдентификатор];
	ИмяТаблицы = ПараметрыЗапроса.ИмяТаблицы;
	
	Если РатМетаданные.ТаблицаСодержитОбъектныеДанные(ИмяТаблицы) Тогда
		
		ТипИдентификатора = РатТипыДанных.ТипПоИмениТаблицы(ИмяТаблицы, "Ссылка");
		Результат = ДесериализоватьЗначение(Идентификатор, ТипИдентификатора, СтатусОбработкиЗапроса, "редактируемый объект");
		
	Иначе
		
		Результат = РатПреобразованияКлючиЗаписи.ДесериализоватьКлючЗаписи(Идентификатор, ИмяТаблицы, СтатусОбработкиЗапроса);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Загружает таблицу из текстового документа в формате Markdown.
//
// Параметры:
//   ТекстовыйДокумент - ТекстовыйДокумент - текстовый документ с таблицей в формате Markdown
//   СтрокаНачало - Число - номер строки начала таблицы (по умолчанию 1)
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с колонками типа Строка, соответствующими колонкам из Markdown
//
// Пример:
//   ТекстовыйДокумент = Новый ТекстовыйДокумент;
//   ТекстовыйДокумент.УстановитьТекст("| Имя | Возраст |" + Символы.ПС + "| Иван | 25 |");
//   Таблица = РатПреобразования.ЗагрузитьТаблицуMarkDown(ТекстовыйДокумент);
//
Функция ЗагрузитьТаблицуMarkDown(ТекстовыйДокумент, СтрокаНачало = 1) Экспорт
	
	Возврат РатПреобразованияВспомогательные.ЗагрузитьТаблицуMarkDown(ТекстовыйДокумент, СтрокаНачало);
	
КонецФункции

// Возвращает имя элемента перечисления.
//
// Параметры:
//   ЗначениеПеречисления - Произвольный - значение перечисления
//
// Возвращаемое значение:
//   Строка - имя элемента перечисления
//
Функция ИмяЭлементаПеречисления(ЗначениеПеречисления) Экспорт
	
	Возврат РатПреобразованияСсылки.ИмяЭлементаПеречисления(ЗначениеПеречисления);

КонецФункции

// Возвращает значения идентификатора записи.
//
// Параметры:
//   Идентификатор - Произвольный - идентификатор записи
//
// Возвращаемое значение:
//   Структура - значения идентификатора записи
//
Функция ЗначенияИдентификатора(Идентификатор) Экспорт
	
	Возврат РатПреобразованияКлючиЗаписи.ЗначенияИдентификатора(Идентификатор);
	
КонецФункции

#Область СистемныеПеречисления

// Возвращает строковое представление системного перечисления.
//
// Параметры:
//   Тип - Тип - тип системного перечисления (например, Тип("ВидДвиженияНакопления"))
//
// Возвращаемое значение:
//   Строка - строковое представление типа (например, "ВидДвиженияНакопления")
//
// Пример:
//   ИмяПеречисления = РатПреобразования.ИмяСистемногоПеречисления(Тип("ВидДвиженияНакопления"));
//   // Результат: "ВидДвиженияНакопления"
//
Функция ИмяСистемногоПеречисления(Тип) Экспорт
	
	Возврат РатПреобразованияСистемныеПеречисления.ИмяСистемногоПеречисления(Тип);
	
КонецФункции

// Возвращает менеджер системного перечисления для доступа к его значениям.
//
// Параметры:
//   ИмяПеречисления - Строка - строковое представление типа системного перечисления
//
// Возвращаемое значение:
//   Произвольный - менеджер системного перечисления, позволяющий обращаться к его значениям
//
// Пример:
//   Менеджер = РатПреобразования.МенеджерСистемногоПеречисления("ВидДвиженияНакопления");
//   Приход = Менеджер.Приход; // ВидДвиженияНакопления.Приход
//
Функция МенеджерСистемногоПеречисления(ИмяПеречисления) Экспорт
	
	Возврат РатПреобразованияСистемныеПеречисления.МенеджерСистемногоПеречисления(ИмяПеречисления);
	
КонецФункции

// Возвращает уникальный ключ значения системного перечисления для сериализации.
//
// Параметры:
//   ЗначениеПеречисления - Произвольный - значение системного перечисления
//
// Возвращаемое значение:
//   Строка - уникальный ключ (например, "Receipt" для ВидДвиженияНакопления.Приход)
//
// Пример:
//   Ключ = РатПреобразования.КлючСистемногоПеречисления(ВидДвиженияНакопления.Приход);
//   // Результат: "Receipt"
//
Функция КлючСистемногоПеречисления(ЗначениеПеречисления) Экспорт
	
	Возврат РатПреобразованияСистемныеПеречисления.КлючСистемногоПеречисления(ЗначениеПеречисления);
	
КонецФункции

// Возвращает массив всех ключей значений системного перечисления для сериализации.
//
// Параметры:
//   МенеджерПеречисления - Произвольный - менеджер системного перечисления
//                        - Строка - имя системного перечисления
//
// Возвращаемое значение:
//   Массив из Строка- массив строк с ключами всех значений перечисления
//
// Пример:
//   Ключи = РатПреобразования.КлючиСистемногоПеречисления(ВидДвиженияНакопления);
//   // Результат: ["Receipt", "Expense"]
//
Функция КлючиСистемногоПеречисления(МенеджерПеречисления) Экспорт
	
	Возврат РатПреобразованияСистемныеПеречисления.КлючиСистемногоПеречисления(МенеджерПеречисления);
	
КонецФункции

// Получает значение системного перечисления по его ключу при десериализации.
//
// Параметры:
//   ОжидаемыйТип - Тип - ожидаемый тип системного перечисления
//   Значение - Строка - ключ значения перечисления (например, "Receipt")
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//
// Возвращаемое значение:
//   Произвольный - значение системного перечисления или Неопределено в случае ошибки
//
// Пример:
//   СтатусОбработкиЗапроса = РатОбщий.НовыйСтатусОбработкиЗапроса();
//   Значение = РатПреобразования.ЗначениеСистемногоПеречисления(
//       Тип("ВидДвиженияНакопления"), "Receipt", СтатусОбработкиЗапроса);
//   // Результат: ВидДвиженияНакопления.Приход
//
Функция ЗначениеСистемногоПеречисления(ОжидаемыйТип, Значение, СтатусОбработкиЗапроса) Экспорт
	
	Возврат РатПреобразованияСистемныеПеречисления.ЗначениеСистемногоПеречисления(ОжидаемыйТип, Значение, СтатусОбработкиЗапроса);
	
КонецФункции

#КонецОбласти

// Сериализует реквизит составного типа в структуру с типом и значением.
//
// Параметры:
//   Значение - Произвольный - значение реквизита составного типа
//
// Возвращаемое значение:
//   Структура, Неопределено - структура со свойствами:
//     * type - Строка - представление типа значения
//     * id - Произвольный - сериализованное значение
//
Функция СериализоватьРеквизитСоставногоТипа(Значение) Экспорт
	
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Структура("type");
	Результат.Вставить("type", РатТипыДанных.ПредставлениеТипа(ТипЗнч(Значение)));
	Результат.Вставить("id", СериализоватьЗначение(Значение));
	
	//@skip-check constructor-function-return-section
	Возврат Результат;
	
КонецФункции

// Десериализует типизированное значение.
//
// Параметры:
//   Значение - Произвольный - значение для десериализации
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//   ПараметрыДесериализации - см. РатПреобразованияВспомогательные.ПараметрыДесериализации
//
// Возвращаемое значение:
//   Произвольный - десериализованное значение
//
Функция ДесериализоватьТипизированноеЗначение(Знач Значение, Знач СтатусОбработкиЗапроса, Знач ПараметрыДесериализации = Неопределено) Экспорт
	
	Возврат РатПреобразованияВспомогательные.ДесериализоватьТипизированноеЗначение(Значение, СтатусОбработкиЗапроса, ПараметрыДесериализации);
	
КонецФункции

// Извлекает реквизиты из тела запроса в соответствии с описанием.
//
// Параметры:
//   ДанныеТелаЗапроса - Структура - данные из тела HTTP-запроса
//   ОписаниеРеквизитов - Соответствие из Тип - описание реквизитов (ключ - имя реквизита, значение - тип)
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//   ОписаниеИсточника - Строка - описание источника данных для логирования
//   ПроверятьНеизвестныеРеквизиты - Булево - проверять наличие неизвестных реквизитов
//   ОбъектныеДанные - Булево - признак объектных данных (по умолчанию Ложь)
//
// Возвращаемое значение:
//   Структура - извлеченные реквизиты
//
Функция РеквизитыИзТела(ДанныеТелаЗапроса,
						ОписаниеРеквизитов,
						СтатусОбработкиЗапроса,
						ОписаниеИсточника,
						ПроверятьНеизвестныеРеквизиты,
						ОбъектныеДанные = Ложь) Экспорт
	
	Попытка
		
		ДанныеЗаписи = Новый Структура;
		
		Для Каждого ОписаниеРеквизита Из ОписаниеРеквизитов Цикл
			ИмяРеквизита = ОписаниеРеквизита.Ключ;
			ТипРеквизита = ОписаниеРеквизита.Значение;
			
			Если ДанныеТелаЗапроса.Свойство(ИмяРеквизита) Тогда
				Описание = СтрШаблон("значение реквизита '%1' %2",  ИмяРеквизита, ОписаниеИсточника);
				
				Если ОбъектныеДанные И СтрСравнить(ИмяРеквизита, "Ссылка") = 0 Тогда
					ТипРеквизита = Тип("УникальныйИдентификатор");
				КонецЕсли;
				
				Значение = ДесериализоватьЗначение(ДанныеТелаЗапроса[ИмяРеквизита], ТипРеквизита, СтатусОбработкиЗапроса, Описание);
				ДанныеЗаписи.Вставить(ИмяРеквизита, Значение);
			КонецЕсли;
		
		КонецЦикла;
		
		Если ПроверятьНеизвестныеРеквизиты Тогда
			Для Каждого Элемент Из ДанныеТелаЗапроса Цикл
				Если НЕ ДанныеЗаписи.Свойство(Элемент.Ключ) Тогда
					ТекстОшибки = СтрШаблон("Передан неизвестный реквизит `%1`", Элемент.Ключ);
					КлассОшибки = РатОбщий.КлассыОшибок().АнализПараметровЗапроса;
					РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассОшибки, ТекстОшибки);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
	Исключение
		ТекстОшибки = РатОбщийКлиентСервер.ТекстОшибки(ИнформацияОбОшибке(), "Не удалось прочитать данные реквизитов " + ОписаниеИсточника);
		КлассОшибки = РатОбщий.КлассыОшибок().АнализПараметровЗапроса;
		РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассОшибки, ТекстОшибки);
	КонецПопытки;
	
	Возврат ДанныеЗаписи;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область Десериализация

// Извлекает из значения информацию о типе и собственно значение.
// Поддерживает несколько форматов типизированных значений:
//   1. Структура с полями type и (id или value)
//   2. Строковое представление с префиксом типа (например, "string.Значение", "Catalog.Контрагенты.УИД")
//
// Параметры:
//   Значение - Произвольный - Значение, из которого извлекается информация о типе
//
// Возвращаемое значение:
//   Структура - Информация о типе и значении:
//     * ПредставлениеТипа - Строка - Текстовое представление типа или Неопределено
//     * Значение - Произвольный - Извлеченное значение
//     * ЭтоТипизированнаяСтрока - Булево - Признак, что значение было извлечено из строки
//
Функция ИзвлечьТипИЗначение(Значение) Экспорт
	
	Возврат РатПреобразованияВспомогательные.ИзвлечьТипИЗначение(Значение);
	
КонецФункции

Функция ПривестиЗначениеКТипу(ПараметрыДесериализации, СтатусОбработкиЗапроса)
	
	ОжидаемыйТип = ПараметрыДесериализации.ОжидаемыйТип;
	Значение = ПараметрыДесериализации.Значение;
	
	Если ПараметрыДесериализации.ТипЗначения = ОжидаемыйТип Тогда
		
		Результат = Значение;
		
	ИначеЕсли НЕ ЗначениеЗаполнено(Значение) Тогда
		
		Если ПараметрыДесериализации.ЭтоСоставнойТип ИЛИ ПараметрыДесериализации.ОграничениеТипа = Неопределено Тогда
			ОписаниеТипа = Новый ОписаниеТипов(РатКоллекции.ЗначениеВМассиве(ОжидаемыйТип));
		Иначе
			ОписаниеТипа = ПараметрыДесериализации.ОграничениеТипа;
		КонецЕсли;
		
		Возврат ОписаниеТипа.ПривестиЗначение(Значение);
		
	КонецЕсли;
	
	Если ОжидаемыйТип = Тип("Дата") Тогда
		
		Результат = ЗначениеВДату(Значение, СтатусОбработкиЗапроса);
		
	ИначеЕсли ОжидаемыйТип = Тип("Неопределено") ИЛИ ОжидаемыйТип = Тип("Null") Тогда
		
		Результат = Неопределено;
		
	ИначеЕсли РатТипыДанных.ЭтоСсылочныйТип(ОжидаемыйТип) Тогда
		
		Результат = РатПреобразованияСсылки.ДесериализоватьСсылку(ПараметрыДесериализации, СтатусОбработкиЗапроса);
		
	ИначеЕсли ОжидаемыйТип = Тип("УникальныйИдентификатор") И РатСтроки.ЭтоУникальныйИдентификатор(Значение) Тогда
		
		Результат = Новый УникальныйИдентификатор(Значение);
		
	ИначеЕсли ОжидаемыйТип = Тип("Булево") Тогда
		
		Результат = ЗначениеВБулево(Значение, СтатусОбработкиЗапроса);
		
	ИначеЕсли ОжидаемыйТип = Тип("Число") Тогда
		
		Результат = ЗначениеВЧисло(Значение, СтатусОбработкиЗапроса);
		
	ИначеЕсли ОжидаемыйТип = Тип("Строка") Тогда
		
		Результат = ЗначениеВСтроку(Значение, СтатусОбработкиЗапроса);
		
	ИначеЕсли РатТипыДанных.ЭтоСистемноеПеречисление(ОжидаемыйТип) Тогда
		
		Результат = ЗначениеСистемногоПеречисления(ОжидаемыйТип, Значение, СтатусОбработкиЗапроса);
		
	ИначеЕсли ОжидаемыйТип = Тип("ХранилищеЗначения") Тогда
		
		Результат = Новый ХранилищеЗначения(ДесериализоватьПроизвольноеЗначение(Значение, СтатусОбработкиЗапроса));
		
	Иначе
		
		ТекстОшибки = СтрШаблон("Не удалось получить значение для типа ""%1"", значение = %2", ОжидаемыйТип, Значение);
		КлассОшибки = РатОбщий.КлассыОшибок().Десериализация;
		РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассОшибки, ТекстОшибки);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Преобразует строковое значение в дату при десериализации.
// Поддерживает различные форматы даты и времени, включая ISO 8601.
//
// Параметры:
//   Значение - Строка - значение для преобразования в дату
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//
// Возвращаемое значение:
//   Дата, Неопределено - преобразованное значение или Неопределено в случае ошибки
//
// Пример:
//   СтатусОбработкиЗапроса = РатОбщий.НовыйСтатусОбработкиЗапроса();
//   РатПреобразования.ЗначениеВДату("2024-01-15T12:30:00", СтатусОбработкиЗапроса); // 15.01.2024 12:30:00
//   РатПреобразования.ЗначениеВДату("12:30:00", СтатусОбработкиЗапроса); // 01.01.0001 12:30:00
//
Функция ЗначениеВДату(Значение, СтатусОбработкиЗапроса) Экспорт
	
	Возврат РатПреобразованияПримитивы.ЗначениеВДату(Значение, СтатусОбработкиЗапроса);
	
КонецФункции

// Преобразует значение в булево при десериализации.
//
// Параметры:
//   Значение - Произвольный - значение для преобразования (строка, число, булево)
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//
// Возвращаемое значение:
//   Булево, Неопределено - преобразованное значение или Неопределено в случае ошибки
//
// Пример:
//   СтатусОбработкиЗапроса = РатОбщий.НовыйСтатусОбработкиЗапроса();
//   РатПреобразования.ЗначениеВБулево("true", СтатусОбработкиЗапроса); // Истина
//   РатПреобразования.ЗначениеВБулево(1, СтатусОбработкиЗапроса); // Истина
//   РатПреобразования.ЗначениеВБулево("да", СтатусОбработкиЗапроса); // Истина
//
Функция ЗначениеВБулево(Знач Значение, СтатусОбработкиЗапроса) Экспорт
	
	Возврат РатПреобразованияПримитивы.ЗначениеВБулево(Значение, СтатусОбработкиЗапроса);
	
КонецФункции

// Преобразует значение в число при десериализации.
//
// Параметры:
//   Значение - Произвольный - значение для преобразования (строка, число)
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//
// Возвращаемое значение:
//   Число, Неопределено - преобразованное значение или Неопределено в случае ошибки
//
// Пример:
//   СтатусОбработкиЗапроса = РатОбщий.НовыйСтатусОбработкиЗапроса();
//   РатПреобразования.ЗначениеВЧисло("123.45", СтатусОбработкиЗапроса); // 123.45
//   РатПреобразования.ЗначениеВЧисло("123,45", СтатусОбработкиЗапроса); // 123.45
//
Функция ЗначениеВЧисло(Значение, СтатусОбработкиЗапроса) Экспорт
	
	Возврат РатПреобразованияПримитивы.ЗначениеВЧисло(Значение, СтатусОбработкиЗапроса);
	
КонецФункции

// Преобразует значение в строку при десериализации.
//
// Параметры:
//   Значение - Произвольный - значение для преобразования
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//
// Возвращаемое значение:
//   Строка, Неопределено - преобразованное значение или Неопределено в случае ошибки
//
// Пример:
//   СтатусОбработкиЗапроса = РатОбщий.НовыйСтатусОбработкиЗапроса();
//   РатПреобразования.ЗначениеВСтроку(123, СтатусОбработкиЗапроса); // "123"
//
Функция ЗначениеВСтроку(Значение, СтатусОбработкиЗапроса) Экспорт
	
	Возврат РатПреобразованияПримитивы.ЗначениеВСтроку(Значение, СтатусОбработкиЗапроса);
	
КонецФункции

// Сериализует примитивное значение для передачи в JSON.
//
// Параметры:
//   Значение - Произвольный - примитивное значение для сериализации
//   ТипЗначения - Тип - тип значения
//
// Возвращаемое значение:
//   Строка, Число, Булево, Неопределено - сериализованное значение
//
// Пример:
//   РатПреобразования.СериализоватьПримитив(Дата(2024, 1, 15, 12, 30, 0), Тип("Дата"));
//   // Результат: "2024-01-15T12:30:00"
//
Функция СериализоватьПримитив(Значение, ТипЗначения) Экспорт
	
	Возврат РатПреобразованияПримитивы.СериализоватьПримитив(Значение, ТипЗначения);
	
КонецФункции

// Десериализует примитивное значение из JSON.
//
// Параметры:
//   Значение - Произвольный - значение для десериализации
//   ОжидаемыйТип - Тип - ожидаемый тип результата
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//
// Возвращаемое значение:
//   Произвольный - десериализованное значение примитивного типа
//
// Пример:
//   СтатусОбработкиЗапроса = РатОбщий.НовыйСтатусОбработкиЗапроса();
//   РатПреобразования.ДесериализоватьПримитив("2024-01-15T12:30:00", Тип("Дата"), СтатусОбработкиЗапроса);
//   // Результат: 15.01.2024 12:30:00
//
Функция ДесериализоватьПримитив(Значение, ОжидаемыйТип, СтатусОбработкиЗапроса) Экспорт
	
	Возврат РатПреобразованияПримитивы.ДесериализоватьПримитив(Значение, ОжидаемыйТип, СтатусОбработкиЗапроса);
	
КонецФункции

Функция СхемаНастроекЗаписи()
	
	Схема = Новый Массив;
	
	ОписаниеРеквизита = ОписаниеРеквизита("ОбменДаннымиЗагрузка", Тип("Булево"));
	ОписаниеРеквизита.Псевдонимы = СтрРазделить("dataExchangeParametersLoad", ",");
	Схема.Добавить(ОписаниеРеквизита);
	
	ОписаниеРеквизита = ОписаниеРеквизита("Замещать", Тип("Булево"));
	ОписаниеРеквизита.Псевдонимы = СтрРазделить("replace", ",");
	Схема.Добавить(ОписаниеРеквизита);
	
	ОписаниеРеквизита = ОписаниеРеквизита("РежимЗаписи", Тип("РежимЗаписиДокумента"));
	ОписаниеРеквизита.Псевдонимы = СтрРазделить("writeMode", ",");
	Схема.Добавить(ОписаниеРеквизита);
	
	ОписаниеРеквизита = ОписаниеРеквизита("РежимПроведения", Тип("РежимПроведенияДокумента"));
	ОписаниеРеквизита.Псевдонимы = СтрРазделить("postingMode", ",");
	Схема.Добавить(ОписаниеРеквизита);
	
	Возврат Схема;
	
КонецФункции

Функция ПреобразованноеЗначение(СыроеЗначение, ОписаниеРеквизита, СтатусОбработкиЗапроса, Описание)
	
	Возврат РатПреобразованияВспомогательные.ПреобразованноеЗначение(СыроеЗначение, ОписаниеРеквизита, СтатусОбработкиЗапроса, Описание);

КонецФункции

// Десериализует произвольное значение без указания типа.
//
// Параметры:
//   Значение - Произвольный - значение для десериализации
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//
// Возвращаемое значение:
//   Произвольный - десериализованное значение
//
Функция ДесериализоватьПроизвольноеЗначение(Значение, СтатусОбработкиЗапроса) Экспорт
	
	Возврат РатПреобразованияВспомогательные.ДесериализоватьПроизвольноеЗначение(Значение, СтатусОбработкиЗапроса);
	
КонецФункции

#КонецОбласти

Процедура ИзвлечьДанныеОбъекта(ДанныеЗаписи, Данные, ИмяТаблицы, СтатусОбработкиЗапроса)
	
	ОбъектныеДанные = РатМетаданные.ТаблицаСодержитОбъектныеДанные(ИмяТаблицы);
	РеквизитыЗаписи = РатПовтИсп.СтруктураТаблицы(ИмяТаблицы);
	
	ТипДанныхЭтоСтруктура = РатТипыДанных.ЭтоСтруктура(Данные);
	
	Если ТипДанныхЭтоСтруктура И ОбъектныеДанные Тогда
		ИзвлечьДанныеОбъектаИзСтруктуры(ДанныеЗаписи, Данные, РеквизитыЗаписи, СтатусОбработкиЗапроса);
	ИначеЕсли ТипДанныхЭтоСтруктура И НЕ ОбъектныеДанные Тогда
		ИзвлечьДанныеРегистраИзСтруктуры(ДанныеЗаписи, Данные, РеквизитыЗаписи, СтатусОбработкиЗапроса);
	ИначеЕсли РатТипыДанных.ЭтоМассив(Данные) Тогда
		ИзвлечьДанныеИзМассива(ДанныеЗаписи, Данные, РеквизитыЗаписи, СтатусОбработкиЗапроса);
	Иначе
		ЗафиксироватьОшибкуНеверногоТипа(СтатусОбработкиЗапроса);
	КонецЕсли;
	
КонецПроцедуры

Процедура ИзвлечьДанныеОбъектаИзСтруктуры(ДанныеЗаписи, Данные, РеквизитыЗаписи, СтатусОбработкиЗапроса)
	
	Реквизиты = РеквизитыИзТела(Данные, РеквизитыЗаписи.Реквизиты, СтатусОбработкиЗапроса, "объекта", Ложь, Истина);
	РатКоллекции.ОбъединитьВСтруктуру(ДанныеЗаписи.Реквизиты, Реквизиты);
	
	Для Каждого ОписаниеТЧ Из РеквизитыЗаписи.ТабличныеЧасти Цикл
		ОбработатьТабличнуюЧасть(ДанныеЗаписи, Данные, ОписаниеТЧ, СтатусОбработкиЗапроса);
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбработатьТабличнуюЧасть(ДанныеЗаписи, Данные, ОписаниеТЧ, СтатусОбработкиЗапроса)
	
	Если НЕ Данные.Свойство(ОписаниеТЧ.Ключ) Тогда
		Возврат;
	КонецЕсли;
	
	РеквизитыТЧ = ОписаниеТЧ.Значение;
	ДанныеТЧ = Данные[ОписаниеТЧ.Ключ];
	
	Если РатТипыДанных.ЭтоМассив(ДанныеТЧ) Тогда
		
		ТабличнаяЧасть = Новый Массив;
		ДанныеЗаписи.ТабличныеЧасти.Вставить(ОписаниеТЧ.Ключ, ТабличнаяЧасть);
		
		Для Инд = 0 По ДанныеТЧ.ВГраница() Цикл
			
			Описание = СтрШаблон("табличной части '%1[%2]'", ОписаниеТЧ.Ключ, Инд);
			ЗаписьТабличнойЧасти = РеквизитыИзТела(ДанныеТЧ[Инд], РеквизитыТЧ, СтатусОбработкиЗапроса, Описание, Истина);
			ТабличнаяЧасть.Добавить(ЗаписьТабличнойЧасти);
			
		КонецЦикла;
		
	ИначеЕсли ДанныеТЧ <> Неопределено Тогда
		
		ТекстОшибки = СтрШаблон("Не верное значение табличной части '%1'.
								|Для передачи данных табличной части нужно использовать массив объектов", ОписаниеТЧ.Ключ);
		КлассОшибки = РатОбщий.КлассыОшибок().АнализПараметровЗапроса;
		РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассОшибки, ТекстОшибки);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ИзвлечьДанныеРегистраИзСтруктуры(ДанныеЗаписи, Данные, РеквизитыЗаписи, СтатусОбработкиЗапроса)
	
	РеквизитыСтроки = РеквизитыИзТела(Данные, РеквизитыЗаписи.Реквизиты, СтатусОбработкиЗапроса, "записи регистра", Истина);
	ДанныеЗаписи.Данные.Добавить(РеквизитыСтроки);
	
КонецПроцедуры

Процедура ИзвлечьДанныеИзМассива(ДанныеЗаписи, Данные, РеквизитыЗаписи, СтатусОбработкиЗапроса)
	
	Для Каждого СтрокаДанных Из Данные Цикл
		РеквизитыСтроки = РеквизитыИзТела(СтрокаДанных,
										  РеквизитыЗаписи.Реквизиты,
										  СтатусОбработкиЗапроса,
										  "строки набора записей",
										  Истина);
		ДанныеЗаписи.Данные.Добавить(РеквизитыСтроки);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗафиксироватьОшибкуНеверногоТипа(СтатусОбработкиЗапроса)
	
	ТекстОшибки = "Тело должно иметь тип Структура";
	КлассОшибки = РатОбщий.КлассыОшибок().АнализПараметровЗапроса;
	РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассОшибки, ТекстОшибки);
	
КонецПроцедуры

// Возвращает псевдонимы примитивных типов для сериализации.
//
// Возвращаемое значение:
//   ФиксированнаяСтруктура - псевдонимы типов (ключ - имя типа, значение - псевдоним)
//
// Пример:
//   Псевдонимы = РатПреобразования.ПсевдонимыПримитивныхТипов();
//   Псевдоним = Псевдонимы["Строка"]; // "string"
//
Функция ПсевдонимыПримитивныхТипов() Экспорт
	
	Возврат РатПреобразованияПримитивы.ПсевдонимыПримитивныхТипов();
	
КонецФункции

#КонецОбласти
