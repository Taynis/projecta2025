//©///////////////////////////////////////////////////////////////////////////©//
//
//  Copyright 2021-2025 BIA-Technologies Limited Liability Company
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
//©///////////////////////////////////////////////////////////////////////////©//

/////////////////////////////////////////////////////////////////////////////////
// Строковые функции
/////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Функция проверяет, является ли переданная строка уникальным идентификатором
//
// Параметры:
//  ИдентификаторСтрока	 - Строка	 - проверяемая строка
// 
// Возвращаемое значение:
//  Булево - Если строка соответствует форму уникального идентификатора, то ИСТИНА
//
// Пример:
//   Результат = РатСтроки.ЭтоУникальныйИдентификатор("a772d037-9519-4c2b-8c9b-ad9de187fe90");
//   // вернет Истина
Функция ЭтоУникальныйИдентификатор(ИдентификаторСтрока) Экспорт
	
	УИСтрока = ИдентификаторСтрока;
	Шаблон = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
	
	Если СтрДлина(Шаблон) <> СтрДлина(УИСтрока) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Для Сч = 1 По СтрДлина(УИСтрока) Цикл
		
		Если НЕ ЭтоСимволУникальногоИдентификатора(УИСтрока, Сч, Шаблон) Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;

КонецФункции // ЭтоУникальныйИдентификатор

// Формирует строку повторяющихся символов заданной длины
//
// Параметры:
//  Символ - Строка - Символ, из которых будет состоять итоговая строка
//  КоличествоСимволов - Число - Длина строки
// 
// Возвращаемое значение:
//  Строка - Сформированная строка
//
// Пример:
//   Строка = РатСтроки.СформироватьСтрокуСимволов("*", 5);
//   // вернет "*****"
Функция СформироватьСтрокуСимволов(Символ, КоличествоСимволов) Экспорт
	
	// возвращаемое значение функции
	Результат = "";
	
	Для Индекс = 1 По КоличествоСимволов Цикл // BSLLS:UnusedLocalVariable-off
		
		Результат = Результат + Символ;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает признак наличия в строке указанного префикса
// 
// Параметры:
//  ИсходнаяСтрока - Строка - проверяемая строка
//  Префикс - Строка - искомый префикс
//  Разделитель - Строка - строка разделителя, которая будет добавлена к префиксу при поиске в проверяемой строке
//  СУчетомРегистра - Булево - если Ложь, поиск префикса будет осуществлен без учета регистра
//
// Возвращаемое значение:
//  Булево - результат поиска префикса
//
// Пример:
//   Результат = РатСтроки.СтрокаСодержитПрефикс("Привет, мир!", "Привет", ",", Ложь);
//   // вернет Истина
Функция СтрокаСодержитПрефикс(Знач ИсходнаяСтрока, Знач Префикс, Знач Разделитель = "", Знач СУчетомРегистра = Истина) Экспорт
	
	Возврат СтрокаСодержитАффикс(ИсходнаяСтрока, Префикс, Истина, Разделитель, СУчетомРегистра);
	
КонецФункции

// Возвращает строку, обрезанную слева указанным префиксом и разделителем, если начало строки соответствует этому
// 
// Параметры:
//  ИсходнаяСтрока - Строка - строка-источник
//  Префикс - Строка - строка, которая будет отрезана слева от исходной, если соответствует её началу
//  Разделитель - Строка - строка разделителя, которая будет добавлена к префиксу при поиске и исключении из исходной строки
//  СУчетомРегистра - Булево - если Ложь, поиск префикса будет осуществлен без учета регистра
//
// Возвращаемое значение:
//  Строка - результат сокращения исходной строки
//
// Пример:
//   Результат = РатСтроки.СократитьПрефикс("Привет, мир!", "Привет", ",", Ложь); 
//   // вернет "мир!"
Функция СократитьПрефикс(Знач ИсходнаяСтрока, Знач Префикс, Знач Разделитель = "", Знач СУчетомРегистра = Истина) Экспорт
	
	Возврат СократитьАффикс(ИсходнаяСтрока, Префикс, Истина, Разделитель, СУчетомРегистра);
	
КонецФункции

// Анализирует строку на наличие символов отличных от цифры, 
// предоставляет возможность получить список некорректных символов и чистку строки
//
// Параметры:
//  СтрокаПроверки - Строка - анализируемая строка
//  СтрокаНайденныхНедопустимыхСимволов - Строка - строковый список некорректных символов
//  УдалитьНайденныеНедопустимыеСимволы - Булево - признак необходимости чистки строки
//  УчитыватьПробелы - Булево - признак необходимости удалять пробелы в строке
// 
// Возвращаемое значение:
//  Булево - признак содержания в строке только цифр
//
// Пример:
//   СтрокаОшибок = "";
//   Результат = РатСтроки.СтрокаСодержитТолькоЦифры("123abc456", СтрокаОшибок, Истина, Истина); 
//   // вернет Ложь, СтрокаОшибок = "abc"
Функция СтрокаСодержитТолькоЦифры(СтрокаПроверки, СтрокаНайденныхНедопустимыхСимволов = Неопределено,
				УдалитьНайденныеНедопустимыеСимволы = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") ИЛИ СтрокаПроверки = "" Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	СтрокаОбработки = СтрокаПроверки;
	
	Если НЕ УчитыватьПробелы Тогда
		
		СтрокаОбработки = СтрЗаменить(СтрокаПроверки, " ", "");
		
	КонецЕсли;
	
	МассивПодстрок = СтрРазделить(СтрокаОбработки, Цифры(), Ложь);
	
	Если СтрокаНайденныхНедопустимыхСимволов = Неопределено И НЕ УдалитьНайденныеНедопустимыеСимволы Тогда
		
		Возврат МассивПодстрок.Количество() = 0;
		
	КонецЕсли;
	
	СтрокаНайденныхНедопустимыхСимволов = СтрСоединить(МассивПодстрок);
	
	Если УдалитьНайденныеНедопустимыеСимволы Тогда
		
		СтрокаПроверки = СтрСоединить(СтрРазделить(СтрокаПроверки, СтрокаНайденныхНедопустимыхСимволов));
		
	КонецЕсли;
	
	Возврат СтрокаНайденныхНедопустимыхСимволов = "";
	
КонецФункции

// Удаляет повторяющиеся символы слева/справа в переданной строке
//
// Параметры:
//  Строка - Строка - исходная строка, из которой необходимо удалить повторяющиеся символы
//  Символ - Строка - значение символа, который необходимо удалить
//  Режим - Строка - Вариант [Слева|Справа]. Режим добавления символов к исходной строке: слева или справа
// 
// Возвращаемое значение:
//  Строка - Обработанная строка
//
// Пример:
//   Результат = РатСтроки.УдалитьПовторяющиесяСимволы("///путь/к/файлу///", "/", "Слева");
//   // вернет "путь/к/файлу///"
Функция УдалитьПовторяющиесяСимволы(Знач Строка, Знач Символ, Знач Режим = "Слева") Экспорт
	
	Если ВРег(Режим) = "СЛЕВА" Тогда
		
		Пока СтрНачинаетсяС(Строка, Символ) Цикл
			
			Строка = Сред(Строка, 2);
			
		КонецЦикла;
		
	ИначеЕсли ВРег(Режим) = "СПРАВА" Тогда
		
		Пока СтрЗаканчиваетсяНа(Строка, Символ) Цикл
			
			Строка = Лев(Строка, СтрДлина(Строка) - 1);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции

// Конкатенирует строки, разделяя их разделителем
//
// Параметры:
//  ИсходнаяСтрока - Строка - Исходная строка
//  ДополнительнаяСтрока - Строка - Добавляемая строка
//  Разделитель - Строка - Строка разделитель, любой набор символов - разделитель между подстроками
// 
// Возвращаемое значение:
//  Строка - Результат конкатенации строк
//
// Пример:
//   Результат = РатСтроки.ДобавитьСтроку("строка1", "строка2", "|"); 
//   // вернет "строка1|строка2"
Функция ДобавитьСтроку(Знач ИсходнаяСтрока, Знач ДополнительнаяСтрока, Знач Разделитель = ";") Экспорт
	
	Если НЕ ПустаяСтрока(ДополнительнаяСтрока) Тогда
		
		Если Не ПустаяСтрока(ИсходнаяСтрока) Тогда
			
			Возврат Строка(ИсходнаяСтрока) + Разделитель + Строка(ДополнительнаяСтрока);
			
		Иначе
			
			Возврат Строка(ДополнительнаяСтрока);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Строка(ИсходнаяСтрока);
	
КонецФункции

// Возвращает строку букв русского алфавита
//
// Параметры:
//  ДваРегистра - Булево - если истина, результат будет содержать буквы в верхнем и нижнем регистрах, иначе только в нижнем
// 
// Возвращаемое значение:
//  Строка - все русские буквы
//
// Пример:
//   Строка = РатСтроки.РусскиеБуквы(Истина); 
//   // вернет "абвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
Функция РусскиеБуквы(ДваРегистра = Ложь) Экспорт
	
	Результат = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	
	Если ДваРегистра Тогда
		
		Результат = Результат + ВРег(Результат);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает строку букв английского алфавита
//
// Параметры:
//  ДваРегистра - Булево - если истина, результат будет содержать буквы в верхнем и нижнем регистрах, иначе только в нижнем
// 
// Возвращаемое значение:
//  Строка - все английские буквы
//
// Пример:
//   Строка = РатСтроки.АнглийскиеБуквы(Истина); 
//   // вернет "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
Функция АнглийскиеБуквы(ДваРегистра = Ложь) Экспорт
	
	Результат = "abcdefghijklmnopqrstuvwxyz";
	
	Если ДваРегистра Тогда
		
		Результат = Результат + ВРег(Результат);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает строку десятичных цифр
// 
// Возвращаемое значение:
//  Строка - все цифры от 0 до 9
//
// Пример:
//   Строка = РатСтроки.Цифры(); // вернет "0123456789"
//
Функция Цифры() Экспорт
	
	Возврат "0123456789";
	
КонецФункции

// Формирует строку из набора символов на основе указанных параметров
//
// Параметры:
//  Русские - Булево - включить русские буквы в результат
//  Английские - Булево - включить английские буквы в результат
//  Цифры - Булево - включить цифры в результат
//  ДваРегистра - Булево - если истина, буквы будут в верхнем и нижнем регистрах
//  ДополнительныеСимволы - Строка - дополнительные символы для включения в результат
// 
// Возвращаемое значение:
//  Строка - сформированный набор символов
//
// Пример:
//   Строка = РатСтроки.НаборСимволов(Истина, Истина, Истина, Истина, "!@#$");
//   // вернет строку, содержащую русские и английские буквы в обоих регистрах, цифры и указанные символы
Функция НаборСимволов(Русские, Английские, Цифры, ДваРегистра, ДополнительныеСимволы = Неопределено) Экспорт
	
	Результат = Новый Массив();
	
	Если Русские Тогда
		Результат.Добавить(РусскиеБуквы(ДваРегистра));
	КонецЕсли;
	
	Если Английские Тогда
		Результат.Добавить(АнглийскиеБуквы(ДваРегистра));
	КонецЕсли;
	
	Если Цифры Тогда
		Результат.Добавить(Цифры());
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДополнительныеСимволы) Тогда
		Результат.Добавить(ДополнительныеСимволы);
	КонецЕсли;
	
	Возврат СтрСоединить(Результат);
	
КонецФункции

#Область ПреобразованиеОшибок

// Функция возвращает нужное представление данных об ошибке
//
// Параметры:
//  ДанныеОшибки - ИнформацияОбОшибке - Описание ошибки
//  Подробно - Булево
// 
// Возвращаемое значение:
//  Строка - строковое представление ошибки
//
// Пример:
//   ТекстОшибки = РатСтроки.ПредставлениеОшибки(ИнформацияОбОшибке());
Функция ПредставлениеОшибки(ДанныеОшибки, Подробно = Истина) Экспорт
	
	Если ТипЗнч(ДанныеОшибки) = Тип("Строка") Тогда
		
		Возврат ДанныеОшибки;
		
	КонецЕсли;
	
	Если ДанныеОшибки = Неопределено Тогда
			
		Возврат "Неизвестная ошибка.";
	
	КонецЕсли;
	
	Если Подробно Тогда
		
		//@skip-check bsl-legacy-check-static-feature-access
		Возврат ПодробноеПредставлениеОшибки(ДанныеОшибки); // BSLLS:DeprecatedMethods8317-off
		
	Иначе
		
		//@skip-check bsl-legacy-check-static-feature-access
		Возврат КраткоеПредставлениеОшибки(ДанныеОшибки); // BSLLS:DeprecatedMethods8317-off
		
	КонецЕсли;
	
КонецФункции // ПолучитьПредставлениеОшибки

// Преобразовывает объект ИнформацияОбОшибке в строку
//
// Параметры:
//  Ошибка - ИнформацияОбОшибке - ИнформацияОбОшибке
//  НомерПричины - Число - Номер причины ошибки (служебный параметр)
// 
// Возвращаемое значение:
//  Строка - Строковое представление ошибки
//
// Пример:
//   ТекстОшибки = РатСтроки.ИнформациюОбОшибкеВСтроку(ИнформацияОбОшибке());
Функция ИнформациюОбОшибкеВСтроку(Ошибка, НомерПричины = 0) Экспорт
	
	ТекстОшибки = "";
	
	Если Ошибка = Неопределено Тогда
		
		ТекстОшибки = "Неизвестная ошибка.";
		
	Иначе
		
		Если Не ПустаяСтрока(Ошибка.ИмяМодуля) Тогда
			ТекстОшибки = СтрШаблон("%1 {%2(%3)}", ТекстОшибки, Ошибка.ИмяМодуля, Ошибка.НомерСтроки);
		КонецЕсли;
		
		ТекстОшибки = ТекстОшибки + Ошибка.Описание
			+ ?(ПустаяСтрока(Ошибка.ИсходнаяСтрока), "", Символы.ПС
			+ Ошибка.ИсходнаяСтрока);
		
		Если Ошибка.Причина <> Неопределено Тогда
										
			НомерПричиныСтрока = ЧислоВСтроку(НомерПричины + 1);
			ТекстПричины = ИнформациюОбОшибкеВСтроку(Ошибка.Причина, НомерПричины + 1);
			ТекстОшибки = СтрШаблон("%1
									|
									|ПРИЧИНА №%2
									|%3", ТекстОшибки, НомерПричиныСтрока, ТекстПричины);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ТекстОшибки;
	
КонецФункции // ИнформациюОбОшибкеВСтроку

#КонецОбласти

// Объединяет несколько частей URL-пути в один путь
//
// Параметры:
//  Путь1 - Строка - первая часть пути
//  Путь2 - Строка - вторая часть пути
//  Путь3 - Строка - третья часть пути (опционально)
//  Путь4 - Строка - четвертая часть пути (опционально)
//  Путь5 - Строка - пятая часть пути (опционально)
// 
// Возвращаемое значение:
//  Строка - объединенный URL-путь
//
// Пример:
//   Путь = РатСтроки.ОбъединитьПутиURL("api", "v1", "users"); 
//   // вернет "api/v1/users"
Функция ОбъединитьПутиURL(Путь1, Путь2, Путь3 = Неопределено, Путь4 = Неопределено, Путь5 = Неопределено) Экспорт
	
	Возврат ОбъединитьПути("/", Путь1, Путь2, Путь3, Путь4, Путь5);
	
КонецФункции

// Объединяет несколько частей пути с использованием указанного разделителя
//
// Параметры:
//  Разделитель - Строка - символ или строка, используемая для разделения частей пути
//  Путь1 - Строка - первая часть пути
//  Путь2 - Строка - вторая часть пути
//  Путь3 - Строка - третья часть пути (опционально)
//  Путь4 - Строка - четвертая часть пути (опционально)
//  Путь5 - Строка - пятая часть пути (опционально)
// 
// Возвращаемое значение:
//  Строка - объединенный путь
//
// Пример:
//   Путь = РатСтроки.ОбъединитьПути("\\", "C:", "Program Files", "1C"); 
//   // вернет "C:\Program Files\1C"
Функция ОбъединитьПути(Разделитель, Путь1, Путь2, Путь3 = Неопределено, Путь4 = Неопределено, Путь5 = Неопределено) Экспорт
	
	Результат = ДополнитьПуть(Путь1, Путь2, Разделитель);
	
	Если ЗначениеЗаполнено(Путь3) Тогда
		Результат = ДополнитьПуть(Результат, Путь3, Разделитель);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Путь4) Тогда
		Результат = ДополнитьПуть(Результат, Путь4, Разделитель);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Путь5) Тогда
		Результат = ДополнитьПуть(Результат, Путь5, Разделитель);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Форматирует число в строку
//
// Параметры:
//  Число - Число - Форматируемое число
// 
// Возвращаемое значение:
//  Строка - Форматированное число
//
// Пример:
//   Строка = РатСтроки.ЧислоВСтроку(1234.56); // вернет "1234,56"
Функция ЧислоВСтроку(Число) Экспорт
	
	Возврат Формат(Число, "ЧН = 0; ЧГ=");
	
КонецФункции

// Преобразует строку в массив по указанному разделителю
//
// Параметры:
//  Значение - Строка - исходная строка для разбиения
//  Разделитель - Строка - символ или строка, используемая для разделения (по умолчанию ";")
//  УдалятьКонцевыеПробелы - Булево - признак необходимости удаления пробелов в начале и конце каждого элемента
//  Фиксированный - Булево - признак необходимости возврата фиксированного массива
// 
// Возвращаемое значение:
//  Массив из Строка- массив строк, полученный в результате разбиения исходной строки
//
// Пример:
//   Массив = РатСтроки.СтрокуВМассив("a    ;b;c ", ";", Истина); 
//   // вернет массив ["a", "b", "c"]
Функция СтрокуВМассив(Знач Значение, Разделитель = ";", УдалятьКонцевыеПробелы = Ложь, Фиксированный = Ложь) Экспорт
	
	Результат = Новый Массив;
	
	КодУниверсальногоРазделителя = 5855;
	УниверсальныйРазделитель = Символ(КодУниверсальногоРазделителя);
	МодифицированнаяСтрока = СтрЗаменить(Значение, Разделитель, УниверсальныйРазделитель);
	
	МассивСтрок = ?(МодифицированнаяСтрока = "", Новый Массив, СтрРазделить(МодифицированнаяСтрока, УниверсальныйРазделитель));
	
	Если УдалятьКонцевыеПробелы Тогда
		
		Для Индекс = 0 По МассивСтрок.ВГраница() Цикл
			
			МассивСтрок[Индекс] = СокрЛП(МассивСтрок[Индекс]);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если Фиксированный Тогда
		
		Результат = Новый ФиксированныйМассив(МассивСтрок);
		
	Иначе
		
		Результат =  МассивСтрок;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Преобразует строку в формат camel case.
//
// Параметры:
//   ИсходнаяСтрока - Строка - строка для преобразования
//
// Возвращаемое значение:
//   Строка - строка в формате camel case
//
// Пример:
//   Результат = РатСтроки.ПреобразоватьВИдентификатор("Отмена проведения");
//   // Результат: "ОтменаПроведения"
//
Функция ПреобразоватьВИдентификатор(ИсходнаяСтрока) Экспорт
	
	Если ПустаяСтрока(ИсходнаяСтрока) Тогда
		Возврат "";
	КонецЕсли;
	
	// Разделяем строку на слова по пробелам и сразу обрезаем пробелы
	Слова = СтрРазделить(СокрЛП(ИсходнаяСтрока), " ");
	
	// Используем массив для эффективного накопления результата
	ЧастиРезультата = Новый Массив;
	
	Для Каждого Слово Из Слова Цикл
		
		Слово = СокрЛП(Слово);
		
		Если Не ПустаяСтрока(Слово) Тогда
			
			// Более эффективное получение первой буквы и остатка строки
			ПерваяБуква = ВРег(Лев(Слово, 1));
			ОстатокСлова = Сред(Слово, 2);
			
			ЧастиРезультата.Добавить(ПерваяБуква + ОстатокСлова);
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Эффективное объединение всех частей
	Возврат СтрСоединить(ЧастиРезультата, "");
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Проверяет корректность символа в позиции уникального идентификатора.
//
// Параметры:
//   УИСтрока - Строка - строка уникального идентификатора
//   Позиция - Число - позиция символа для проверки
//   Шаблон - Строка - шаблон проверки
//
// Возвращаемое значение:
//   Булево - Истина, если символ корректен
//
Функция ЭтоСимволУникальногоИдентификатора(УИСтрока, Позиция, Шаблон)
	// BSLLS:MagicNumber-off
	КодСимволаШаблона = КодСимвола(Шаблон, Позиция);
	КодСимволаУИ = КодСимвола(УИСтрока, Позиция);
	
	// Проверка символа 'X' (код 88) - должен быть шестнадцатеричной цифрой
	Если КодСимволаШаблона = 88 Тогда
		ЭтоЦифра = КодСимволаУИ >= 48 И КодСимволаУИ <= 57;
		ЭтоБуква = КодСимволаУИ >= 97 И КодСимволаУИ <= 102;
		Возврат ЭтоЦифра Или ЭтоБуква;
	КонецЕсли;
	
	// Проверка символа '-' (код 45) - должен быть дефисом
	Если КодСимволаШаблона = 45 Тогда
		Возврат КодСимволаУИ = 45;
	КонецЕсли;
	// BSLLS:MagicNumber-on
	Возврат Ложь;
	
КонецФункции

// Проверяет наличие аффикса (префикса или суффикса) в строке
//
// Параметры:
//  ИсходнаяСтрока - Строка - проверяемая строка
//  Аффикс - Строка - искомый аффикс
//  Слева - Булево - если истина, проверяется префикс, иначе суффикс
//  Разделитель - Строка - строка разделителя
//  СУчетомРегистра - Булево - признак учета регистра при сравнении
// 
// Возвращаемое значение:
//  Булево - результат проверки наличия аффикса
//
Функция СтрокаСодержитАффикс(ИсходнаяСтрока, Аффикс, Слева, Разделитель, СУчетомРегистра)
	
	Результат = Ложь;
	
	Если ЗначениеЗаполнено(ИсходнаяСтрока) И ЗначениеЗаполнено(Аффикс) Тогда
		
		АффиксСРазделителем = ?(Слева, "", Разделитель) + Аффикс + ?(Слева, Разделитель, "");
		
		Если СУчетомРегистра Тогда
			
			Результат = ?(Слева,
						  СтрНачинаетсяС(ИсходнаяСтрока, АффиксСРазделителем),
						  СтрЗаканчиваетсяНа(ИсходнаяСтрока, АффиксСРазделителем));
			
		Иначе
			
			ДлинаЧасти = СтрДлина(АффиксСРазделителем);
			ЧастьСтроки = ?(Слева, Лев(ИсходнаяСтрока, ДлинаЧасти), Прав(ИсходнаяСтрока, ДлинаЧасти));
			Результат = СтрСравнить(ЧастьСтроки, АффиксСРазделителем) = 0;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Удаляет аффикс (префикс или суффикс) из строки, если он присутствует
//
// Параметры:
//  ИсходнаяСтрока - Строка - исходная строка
//  Аффикс - Строка - удаляемый аффикс
//  Слева - Булево - если истина, удаляется префикс, иначе суффикс
//  Разделитель - Строка - строка разделителя
//  СУчетомРегистра - Булево - признак учета регистра при сравнении
// 
// Возвращаемое значение:
//  Строка - строка без указанного аффикса
//
Функция СократитьАффикс(ИсходнаяСтрока, Аффикс, Слева, Разделитель, СУчетомРегистра)
	
	Результат = ИсходнаяСтрока;
	
	Если ЗначениеЗаполнено(ИсходнаяСтрока)
		И ЗначениеЗаполнено(Аффикс)
		И СтрокаСодержитАффикс(ИсходнаяСтрока, Аффикс, Слева, Разделитель, СУчетомРегистра) Тогда
		
		ДлинаОстатка = СтрДлина(ИсходнаяСтрока) - СтрДлина(Аффикс + Разделитель);
		Если Слева Тогда
			Результат = Прав(ИсходнаяСтрока, ДлинаОстатка);
		Иначе
			Результат = Лев(ИсходнаяСтрока, ДлинаОстатка);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ДополнитьПуть(Путь1, Путь2, Разделитель)
	
	Результат = Неопределено;
	
	Если ЗначениеЗаполнено(Путь1) И ЗначениеЗаполнено(Путь2) Тогда
		
		Если НЕ СтрЗаканчиваетсяНа(Путь1, Разделитель) И НЕ СтрНачинаетсяС(Путь2, Разделитель) Тогда
			Результат = СтрШаблон("%1%2%3", Путь1, Разделитель, Путь2);
		ИначеЕсли СтрЗаканчиваетсяНа(Путь1, Разделитель) И СтрНачинаетсяС(Путь2, Разделитель) Тогда
			// Убираем разделитель из второго пути и склеиваем
			Результат = Путь1 + Сред(Путь2, СтрДлина(Разделитель) + 1);
		Иначе
			Результат = Путь1 + Путь2;
		КонецЕсли;
		
	ИначеЕсли ЗначениеЗаполнено(Путь1) Тогда
		Результат = Путь1;
	Иначе
		Результат = Путь2;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
