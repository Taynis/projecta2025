//©///////////////////////////////////////////////////////////////////////////©//
//
//  Copyright 2021-2025 BIA-Technologies Limited Liability Company
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
//©///////////////////////////////////////////////////////////////////////////©//

#Область СлужебныйПрограммныйИнтерфейс

#Область СтруктурыДанных

Функция ДанныеОбъектаИБ(Данные) Экспорт
	
	Если ЭтоТаблицаГеркен(Данные) Тогда
		ДанныеОбъекта = ТаблицаГеркенВСтруктуру(Данные, Истина);
	ИначеЕсли ЭтоГотовыеДанныеЗапроса(Данные) Тогда
		Возврат Данные;
	Иначе
		ДанныеОбъекта = Данные;
	КонецЕсли;
	
	Возврат Новый Структура("data", ДанныеОбъекта);
	
КонецФункции

Функция ДанныеНабораЗаписей(Данные) Экспорт
	
	Если ЭтоТаблицаГеркен(Данные) Тогда
		ДанныеОбъекта = ТаблицаГеркенВМассивСтруктур(Данные);
	ИначеЕсли ЭтоГотовыеДанныеЗапроса(Данные) Тогда
		Возврат Данные;
	Иначе
		ДанныеОбъекта = Данные;
	КонецЕсли;
	
	Возврат Новый Структура("data", ДанныеОбъекта);
	
КонецФункции

Функция МассивСтруктур(ДанныеТаблица) Экспорт
	
	Если ЭтоТаблицаГеркен(ДанныеТаблица) Тогда
		Возврат ТаблицаГеркенВМассивСтруктур(ДанныеТаблица);
	Иначе
		Возврат ДанныеТаблица;
	КонецЕсли;
	
КонецФункции

Функция СтруктураДанных(Данные, Типизированная, Знач Результат = Неопределено) Экспорт
	
	Если ЭтоТаблицаГеркен(Данные) Тогда
		Возврат ТаблицаГеркенВСтруктуру(Данные, Типизированная, Результат);
	Иначе
		Возврат Данные;
	КонецЕсли;
	
КонецФункции

Функция ДанныеТабличнойЧасти(МетаданныеТабличнойЧасти, Данные) Экспорт
	
	Если ЭтоГотовыеДанныеЗапроса(Данные) Тогда
		Возврат Данные;
	КонецЕсли;
	
	Если ЭтоТаблицаГеркен(Данные) Тогда
		Заголовки = Данные[0];
		Ключи = Новый Структура();
		
		Для Каждого Элемент Из Заголовки Цикл
			ОписаниеКолонки = ОписаниеРеквизита(МетаданныеТабличнойЧасти, Элемент.Значение);
			Ключи.Вставить(Элемент.Ключ, ОписаниеКолонки.Имя);
		КонецЦикла;
		
		ДанныеОбъекта = ТаблицаГеркенВМассивСтруктур(Данные, Ключи);
	Иначе
		ДанныеОбъекта = Данные;
	КонецЕсли;
	
	Возврат Новый Структура("data", ДанныеОбъекта);
	
КонецФункции

Функция СтруктураРеквизитов(Данные, МетаданныеТаблицы, ПолеДанных = "data") Экспорт
	
	Если ЭтоГотовыеДанныеЗапроса(Данные, ПолеДанных) Тогда
		Возврат Данные;
	КонецЕсли;
	
	Если ЭтоТаблицаГеркен(Данные) Тогда
		Результат = Новый Структура();
		
		Для Каждого Строка Из Данные Цикл
			Значение = ЗначениеСтруктурыГеркин(Строка, Истина);
			ОписаниеРеквизита = ОписаниеРеквизита(МетаданныеТаблицы, Строка.Кол1);
			Результат.Вставить(ОписаниеРеквизита.Имя, Значение);
		КонецЦикла;
		
	Иначе
		
		Результат = Данные;
		
	КонецЕсли;
	
	Возврат Новый Структура(ПолеДанных, Результат);
	
КонецФункции

// Преобразует условия поиска в структуру для HTTP-запроса.
//
// Параметры:
//   Условия - Произвольный - условия поиска
//           - Массив из Структура - таблица Геркен
//           - Структура - структура условий
//           - Строка - строка условий
//   ИмяРеквизита - Строка - имя реквизита для условий (по умолчанию "filter")
//
// Возвращаемое значение:
//   Структура - структура с условиями поиска
//
Функция СтруктураПоиска(Условия, ИмяРеквизита = "filter") Экспорт
	
	Если РатТипыДанных.ЭтоМассив(Условия) И ЭтоТаблицаГеркен(Условия) Тогда
		СтруктураУсловий = ТаблицаГеркенВНаборУсловий(Условия);
	ИначеЕсли ЭтоТаблицаУсловий(Условия) Тогда
		СтруктураУсловий = НормализованнаяТаблицаУсловий(Условия);
	ИначеЕсли (РатТипыДанных.ЭтоСтруктура(Условия) И Условия.Свойство(ИмяРеквизита)) ИЛИ РатТипыДанных.ЭтоСтрока(Условия) Тогда
		//@skip-check constructor-function-return-section
		Возврат Условия;
	Иначе
		СтруктураУсловий = Условия;
	КонецЕсли;
	
	Возврат Новый Структура(ИмяРеквизита, СтруктураУсловий);
	
КонецФункции

// Преобразует данные в простой массив значений.
//
// Параметры:
//   Данные - Произвольный - исходные данные:
//          - Строка - строка со значениями через точку с запятой
//          - Массив из Структура - таблица Геркен
//
// Возвращаемое значение:
//   Массив из Произвольный - массив значений
//
// Исключения:
//   Вызывает исключение при неподдерживаемом типе данных
//
Функция ПростойМассивЗначений(Данные) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Данные) Тогда
		Значение = Новый Массив;
	ИначеЕсли ТипЗнч(Данные) = Тип("Строка") Тогда
		Значение = СтрРазделить(Данные, ";");
	ИначеЕсли ЭтоТаблицаГеркен(Данные) Тогда
		Значение = РатКоллекции.ВыгрузитьЗначения(Данные, "Кол1");
	Иначе
		ВызватьИсключение "Неподдерживаемый тип значения";
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

// Подставляет значения переменных из контекста в строку.
//
// Параметры:
//  Контекст - Структура - Контекст с переменными для подстановки
//  Строка - Строка - Строка, в которую нужно подставить значения
//
Процедура ПодставитьПеременныеВСтроку(Контекст, Строка) Экспорт
	
	Если СтрНайти(Строка, "$") = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элем Из Контекст Цикл
		
		Если СтрНайти(Строка, "$" + Элем.Ключ + "$") = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Строка = СтрЗаменить(Строка, "$" + Элем.Ключ + "$", ПредставлениеЗначения(Элем.Значение));
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПредставлениеЗначения(Значение) Экспорт
	
	Если РатТипыДанных.ЭтоСтруктура(Значение) Тогда
		
		Возврат СтрШаблон("%1.%2", Значение.type, Значение.id);
		
	ИначеЕсли Значение = Неопределено Тогда
		
		Возврат "null";
		
	Иначе
		
		Возврат Формат(Значение, "ЧРД=.; ЧН=0; ЧГ=0; ДФ=гггг-ММ-ддTЧЧ:мм:сс; БЛ=false; БИ=true;");
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область Метаданные

Функция СкорректироватьКлючевыеПоля(МетаданныеТабличнойЧасти, КлючевыеПоля) Экспорт
	
	Переименовывания = Переименовывания(МетаданныеТабличнойЧасти, КлючевыеПоля);
	
	Если Переименовывания = Неопределено Тогда
		Возврат КлючевыеПоля;
	Иначе
		// TODO: Странная логика, нужно проверить
		РатКоллекции.ВыгрузитьЗначения(Переименовывания, "Ключ");
	КонецЕсли;
	
КонецФункции

Функция ИмяТабличнойЧасти(МетаданныеТаблицы, ИмяТабличнойЧасти) Экспорт
	
	Если НЕ МетаданныеТаблицы.Свойство("ТабличныеЧасти") Тогда
		ВызватьИсключение СтрШаблон("Таблица `%1` не содержит табличных частей", МетаданныеТаблицы.Имя);
	КонецЕсли;
	
	ОписаниеТабличнойЧасти = НайтиЗначение(МетаданныеТаблицы.ТабличныеЧасти, ИмяТабличнойЧасти, "Ключ");
	
	Если ОписаниеТабличнойЧасти <> Неопределено Тогда
		Возврат ИмяТабличнойЧасти;
	КонецЕсли;
	
	Для Каждого ТабличнаяЧасть Из МетаданныеТаблицы.ТабличныеЧасти Цикл
		
		Если СтрСравнить(ТабличнаяЧасть.Значение.Представление, ИмяТабличнойЧасти) = 0 Тогда
			Возврат ТабличнаяЧасть.Ключ;
		КонецЕсли;
		
	КонецЦикла;
	
	ВызватьИсключение СтрШаблон("Таблица `%1` не содержит табличную часть `%2`", МетаданныеТаблицы.Имя, ИмяТабличнойЧасти);
	
КонецФункции

#КонецОбласти

#Область ИнтерфейсВанессы

Функция ПолучитьМакетОбработки(Ванесса, ИмяМакета) Экспорт
	
	Возврат Ванесса.ПолучитьМакетОбработки(ИмяМакета);
	
КонецФункции

Функция НайтиМакетВКаталогеПроекта(Ванесса, ИмяМакета) Экспорт
	
	Возврат Ванесса.НайтиМакетВКаталогеПроекта(ИмяМакета);
	
КонецФункции

Функция ПолучитьТекстСообщенияПользователю(КонтекстШагов, Сообщение) Экспорт
	
	Возврат КонтекстШагов.Ванесса.ПолучитьТекстСообщенияПользователю(Сообщение);
	
КонецФункции

Функция Локализовать(КонтекстШагов, Строка) Экспорт
	
	Возврат КонтекстШагов.Ванесса.Локализовать(Строка);
	
КонецФункции

Функция ЭталонныйМакет(КонтекстШагов, ИмяЭталонногоМакета) Экспорт
	
	Возврат КонтекстШагов.Ванесса.ПолучитьЭталонМакета(ИмяЭталонногоМакета);
	
КонецФункции

Функция ПроверяемыйМакет(КонтекстШагов, ИмяПеременной) Экспорт
	
	Результат = КонтекстШагов.Ванесса.ПолучитьСохраненноеЗначениеИзКонтекста(ИмяПеременной);
	
	Если Результат = Неопределено Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю(КонтекстШагов, "Переменная <%1> не найдена.");
		ВызватьИсключение СтрШаблон(ТекстСообщения, ИмяПеременной);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает контекст шагов для выполнения.
//
// Параметры:
//   Ванесса - ФормаКлиентскогоПриложения - объект контекста Ванессы
//   Контекст - Структура - контекст выполнения
//   КонтекстСохраняемый - Структура - сохраняемый контекст
//
// Возвращаемое значение:
//   Структура - контекст шагов:
//     * Ванесса - ФормаКлиентскогоПриложения - объект контекста Ванессы
//     * Контекст - Структура - контекст выполнения
//     * КонтекстСохраняемый - Структура - сохраняемый контекст
Функция КонтекстШагов(Ванесса, Контекст, КонтекстСохраняемый) Экспорт
	
	КонтекстШагов = Новый Структура;
	КонтекстШагов.Вставить("Ванесса", Ванесса);
	КонтекстШагов.Вставить("Контекст", Контекст);
	КонтекстШагов.Вставить("КонтекстСохраняемый", КонтекстСохраняемый);
	
	Возврат КонтекстШагов;
	
КонецФункции

#КонецОбласти

Функция ТипизированноеЗначение(Тип, Значение) Экспорт
	
	Если СтрСравнить(Тип, "boolean") = 0 Или СтрСравнить(Тип, "Булево") = 0 Тогда
		Результат = РатПреобразованияКлиентСервер.ВБулево(Значение);
	ИначеЕсли СтрСравнить(Тип, "Число") = 0 Или СтрСравнить(Тип, "decimal") = 0 Тогда
		Результат = РатПреобразованияКлиентСервер.ЧислоИзСтроки(Значение);
	ИначеЕсли СтрСравнить(Тип, "Неопределено") = 0 Или СтрСравнить(Тип, "Null") = 0 Тогда
		Результат = Неопределено;
	Иначе
		Результат = Новый Структура("type, value", Тип, Значение);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура СравнитьИзображенияТабличныхДокументов(КонтекстШагов, ИмяПеременной, ИмяЭталонногоМакета) Экспорт
	
	ТабДокБыло = ЭталонныйМакет(КонтекстШагов, ИмяЭталонногоМакета);
	ТабДокСтало = ПроверяемыйМакет(КонтекстШагов, ИмяПеременной);
	
	РезультатСверки = РатШагиВанессыСервер.СверкаКартинокТабличныхДокументов(ТабДокБыло, ТабДокСтало);
	
	Если РезультатСверки.Совпадают Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ РезультатСверки.КоличествоСовпадает Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю(КонтекстШагов, "Различия в таблицах:");
		СтрокаОшибок = ТекстСообщения + Символы.ПС;
		
		ТекстСообщения = ПолучитьТекстСообщенияПользователю(КонтекстШагов, "Ожидали одинаковое количество картинок: <%1>, а получили <%2>");
		ТекстСообщения = СтрШаблон(ТекстСообщения, РезультатСверки.Количество1, РезультатСверки.Количество2);
		
		СтрокаОшибок = СтрокаОшибок + ТекстСообщения + Символы.ПС;
		
		ТекстСообщения = ПолучитьТекстСообщенияПользователю(КонтекстШагов, "Таблицы должны совпадать, а они различны.%1");
		ТекстСообщения = СтрШаблон(ТекстСообщения, Символы.ПС + СтрокаОшибок);
	Иначе
		ТекстСообщения = ПолучитьТекстСообщенияПользователю(КонтекстШагов, "Различия в таблицах:");
		СтрокаОшибок   = ТекстСообщения + Символы.ПС;
		
		ТекстСообщения = ПолучитьТекстСообщенияПользователю(КонтекстШагов, "Ожидали что картинки будут равны, а они не равны");
		
		СтрокаОшибок = СтрокаОшибок + ТекстСообщения + Символы.ПС;
		
		Для Каждого ИмяКартинки Из РезультатСверки.НесовпадающиеКартинки Цикл
			ТекстСообщения = ПолучитьТекстСообщенияПользователю(КонтекстШагов, "Изображение: %1 отличается");
			ТекстСообщения = СтрШаблон(ТекстСообщения, ИмяКартинки);
			СтрокаОшибок = СтрокаОшибок + ТекстСообщения + Символы.ПС;
		КонецЦикла;
		
		ТекстСообщения = ПолучитьТекстСообщенияПользователю(КонтекстШагов, "Таблицы должны совпадать, а они различны.%1");
		ТекстСообщения = СтрШаблон(ТекстСообщения, Символы.ПС + СтрокаОшибок);
	КонецЕсли;
	
	КонтекстШагов.Ванесса.УстановитьЗначенияТаблицДляСравнения(ТабДокБыло, ТабДокСтало);
	
	КонтекстШагов.Ванесса.ПрикрепитьМакетКСценарию(ТабДокСтало, Локализовать(КонтекстШагов, "ТекущееЗначениеМакета"));
	КонтекстШагов.Ванесса.ПрикрепитьМакетКСценарию(ТабДокБыло, Локализовать(КонтекстШагов, "ЭталонноеЗначениеМакета"));
	
	Если КонтекстШагов.Ванесса.РежимСовместимостиБольшеИлиРавен837 Тогда
		КонтекстШагов.Ванесса.ПрикрепитьМакетКСценарию(КонтекстШагов.Ванесса.ПолучитьРазличияВМакетах(ТабДокБыло, ТабДокСтало),
													   Локализовать(КонтекстШагов, "Различия"));
	КонецЕсли;
	
	КонтекстШагов.Ванесса.ПрикрепитьКСценариюДополнительныеФайлыСравненияЗначенияСЭталоном(ТабДокБыло, ТабДокСтало);
	
	ВызватьИсключение ТекстСообщения;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ЭтоТаблицаГеркен(Данные)
	
	Если ТипЗнч(Данные) <> Тип("Массив") ИЛИ Данные.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Заголовок = Данные[0];
	
	Результат = Истина;
	
	Для Каждого Строка Из Данные Цикл
		
		Если НЕ ЭтоСтрокаТаблицыГеркен(Строка, Заголовок.Количество()) Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ТаблицаГеркенВСтруктуру(Таблица, Типизированная, Знач Результат = Неопределено)
	
	Если Результат = Неопределено Тогда
		Результат = Новый Структура;
	КонецЕсли;
	
	Для Каждого Строка Из Таблица Цикл
		
		Результат.Вставить(Строка.Кол1, ЗначениеСтруктурыГеркин(Строка, Типизированная));
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ТаблицаГеркенВМассивСтруктур(Таблица, Знач Заголовки = Неопределено)
	
	Если Заголовки = Неопределено Тогда
		Заголовки = Таблица[0];
	КонецЕсли;
	
	Данные = Новый Массив;
	
	Для Инд = 1 По Таблица.ВГраница() Цикл
		
		СтрокаТаблицы = Таблица[Инд];
		
		Если НЕ ЭтоСтрокаТаблицыГеркен(СтрокаТаблицы, Заголовки.Количество()) Тогда
			ВызватьИсключение "Таблица имеет некорректную структуру";
		КонецЕсли;
		
		СтрокаДанных = Новый Структура;
		
		Для Каждого Элемент Из Заголовки Цикл
			Значение = СтрокаТаблицы[Элемент.Ключ];
			СтрокаДанных.Вставить(Элемент.Значение, Значение);
		КонецЦикла;
		
		Данные.Добавить(СтрокаДанных);
		
	КонецЦикла;
	
	Возврат Данные;

КонецФункции

// Таблица геркен в набор условий.
// 
// Параметры:
//  Таблица - Массив Из Структура - Таблица
// 
// Возвращаемое значение:
//  Массив из Структура, Структура - Таблица геркен в набор условий
Функция ТаблицаГеркенВНаборУсловий(Таблица)
	
	Колонки = КолонкиТаблицыУсловий();
	ЭтоРасширеннаяТаблицаУсловий = Истина;
	
	Для Каждого Элемент Из Таблица[0] Цикл
		Если НЕ Колонки.Свойство(Элемент.Значение) Тогда
			ЭтоРасширеннаяТаблицаУсловий = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ЭтоРасширеннаяТаблицаУсловий Тогда
		
		ПредварительныеДанные = ТаблицаГеркенВМассивСтруктур(Таблица);
		Результат = НормализованнаяТаблицаУсловий(ПредварительныеДанные);
		
	Иначе
		
		Результат = ТаблицаГеркенВСтруктуру(Таблица, Истина);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция КолонкиТаблицыУсловий()
	
	Колонки = Новый Структура();
	Колонки.Вставить("Реквизит", "key");
	Колонки.Вставить("Значение", "value");
	Колонки.Вставить("Тип", "type");
	Колонки.Вставить("Условие", "condition");
	
	Колонки.Вставить(Колонки.Реквизит, Колонки.Реквизит);
	Колонки.Вставить(Колонки.Значение, Колонки.Значение);
	Колонки.Вставить(Колонки.Тип, Колонки.Тип);
	Колонки.Вставить(Колонки.Условие, Колонки.Условие);
	
	Возврат Колонки;
	
КонецФункции

Функция ЭтоТаблицаУсловий(Таблица)
	
	Если НЕ РатТипыДанных.ЭтоМассив(Таблица) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Колонки = КолонкиТаблицыУсловий();
	
	Для Каждого Строка Из Таблица Цикл
		
		Для Каждого Запись Из Строка Цикл
			
			Если НЕ Колонки.Свойство(Запись.Ключ) Тогда
				Возврат Ложь;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция НормализованнаяТаблицаУсловий(Таблица)
	
	Результат = Новый Массив();
	
	ВидыСравнения = РатОбщийКлиентСервер.ВидыСравнения();
	Ключи = СтрШаблон("%1, Не%1", ВидыСравнения.ВСписке);
	ВозможныМассивы = Новый Структура(Ключи);
	
	Колонки = КолонкиТаблицыУсловий();
	
	Для Каждого Строка Из Таблица Цикл
		Предикат = Новый Структура("condition", ВидыСравнения.Равно);
		
		Для Каждого Элемент Из Строка Цикл
			Предикат.Вставить(Колонки[Элемент.Ключ], Элемент.Значение);
		КонецЦикла;
		
		Если ЗначениеЗаполнено(Предикат.condition) И ВозможныМассивы.Свойство(Предикат.condition) Тогда
			Тип = РатКоллекции.ЗначениеСтруктуры(Предикат, "type", Неопределено);
			Предикат.value = КоллекцияЗначений(Предикат.value, Тип);
		КонецЕсли;
		
		Результат.Добавить(Предикат);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ЭтоСтрокаТаблицыГеркен(Строка, КоличествоСтолбцов)
	
	Если НЕ РатТипыДанных.ЭтоСтруктура(Строка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Результат = Истина;
	
	Для Инд = 1 По Строка.Количество() Цикл
		
		Если НЕ Строка.Свойство("Кол" + Инд) Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если Результат И Строка.Количество() <> КоличествоСтолбцов Тогда
		ВызватьИсключение "Количество колонок строки таблицы не равно количеству колонок таблицы";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ЗначениеСтруктурыГеркин(СтрокаТаблицыГеркин, Типизированная)
	
	Если Типизированная И СтрокаТаблицыГеркин.Свойство("Кол3") И ЗначениеЗаполнено(СтрокаТаблицыГеркин.Кол3) Тогда
		Возврат ТипизированноеЗначение(СтрокаТаблицыГеркин.Кол3, СтрокаТаблицыГеркин.Кол2);
	Иначе
		Возврат СтрокаТаблицыГеркин.Кол2;
	КонецЕсли;
	
КонецФункции

Функция ЭтоГотовыеДанныеЗапроса(Данные, КлючДанных = "data")
	
	Возврат (РатТипыДанных.ЭтоСтруктура(Данные) И Данные.Свойство(КлючДанных)) ИЛИ РатТипыДанных.ЭтоСтрока(Данные);
	
КонецФункции

Функция НайтиЗначение(Коллекция, Значение, РеквизитПоиска)
	
	Для Каждого ОписаниеРеквизита Из Коллекция Цикл
		
		Если СтрСравнить(ОписаниеРеквизита[РеквизитПоиска], Значение) = 0 Тогда
			Возврат ОписаниеРеквизита;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Функция КоллекцияЗначений(Значение, ИмяТипа = Неопределено)
	
	Разделитель = ";";
	
	Если НЕ ЗначениеЗаполнено(ИмяТипа) Тогда
		
		Результат = РатПреобразованияКлиентСервер.СтрокуВМассив(Значение, Разделитель, Истина);
		
	Иначе
		
		Значения = РатПреобразованияКлиентСервер.СтрокуВМассив(Значение, Разделитель, Истина);
		Результат = Новый Массив();
		
		Для Каждого Элемент Из Значения Цикл
			Результат.Добавить(ТипизированноеЗначение(ИмяТипа, Элемент));
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ОписаниеРеквизита(МетаданныеТаблицы, Колонка)
	
	ОписаниеКолонки = НайтиЗначение(МетаданныеТаблицы.Реквизиты, Колонка, "Имя");
	
	Если ОписаниеКолонки = Неопределено Тогда
		ОписаниеКолонки = НайтиЗначение(МетаданныеТаблицы.Реквизиты, Колонка, "Представление");
	КонецЕсли;
	
	Если ОписаниеКолонки = Неопределено Тогда
		ВызватьИсключение СтрШаблон("Табличная часть `%1` не содержит колонку `%2`", МетаданныеТаблицы.Представление, Колонка);
	КонецЕсли;
	
	Возврат ОписаниеКолонки;
	
КонецФункции

Функция Переименовывания(МетаданныеТабличнойЧасти, Колонки)
	
	Переименовывания = Новый Структура();
	
	НужноПереименовывание = Ложь;
	
	Для Каждого Колонка Из Колонки Цикл
		
		ОписаниеКолонки = ОписаниеРеквизита(МетаданныеТабличнойЧасти, Колонка);
		
		Если СтрСравнить(ОписаниеКолонки.Имя, Колонка) <> 0 Тогда
			НужноПереименовывание = Истина;
		КонецЕсли;
		
		Переименовывания.Вставить(ОписаниеКолонки.Имя, Колонка);
		
	КонецЦикла;
	
	Если НЕ НужноПереименовывание Тогда
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

#КонецОбласти
