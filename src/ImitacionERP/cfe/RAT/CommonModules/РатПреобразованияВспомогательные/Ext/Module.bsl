//©///////////////////////////////////////////////////////////////////////////©//
//
//  Copyright 2021-2025 BIA-Technologies Limited Liability Company
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
//©///////////////////////////////////////////////////////////////////////////©//

#Область СлужебныйПрограммныйИнтерфейс

#Область РаботаСТипизированнымиЗначениями

// см. РатПреобразования.ИзвлечьТипИЗначение
Функция ИзвлечьТипИЗначение(Значение) Экспорт
	
	Результат = Новый Структура("ПредставлениеТипа, Значение, ЭтоТипизированнаяСтрока", Неопределено, Значение, Ложь);
	
	Если НЕ РатПреобразованияКлиентСервер.ЭтоТипизированноеЗначение(Значение) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если РатТипыДанных.ЭтоСтруктура(Значение) Тогда
		
		Результат.ПредставлениеТипа = Значение.type;
		Если Значение.Свойство("id") Тогда
			Результат.Значение = Значение.id;
		ИначеЕсли Значение.Свойство("value") Тогда
			Результат.Значение = Значение.value;
		Иначе
			ВызватьИсключение "Не передано значение типизированного реквизита";
		КонецЕсли;
		
		Возврат Результат;
		
	КонецЕсли;
	
	ЧастиЗначения = СтрРазделить(Значение, ".");
	
	Если ЧастиЗначения.Количество() <= 1 ИЛИ НЕ СтрокаМожетБытьИдентификатором(ЧастиЗначения[0]) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Псевдонимы = РатПреобразованияПримитивы.ПсевдонимыПримитивныхТипов();
	Сдвиг = 2;
	
	Если Псевдонимы.Свойство(ЧастиЗначения[0]) Тогда
		
		Результат.ПредставлениеТипа = Псевдонимы[ЧастиЗначения[0]];
		Результат.Значение = Сред(Значение, СтрДлина(ЧастиЗначения[0]) + Сдвиг);
		Результат.ЭтоТипизированнаяСтрока = Истина;
		
	ИначеЕсли ЧастиЗначения.Количество() >= 3
		И (РатМетаданные.ТипМетаданных(ЧастиЗначения[0]) <> Неопределено Или СтрЗаканчиваетсяНа(ЧастиЗначения[0], "Ref")) Тогда
		
		Результат.ПредставлениеТипа = СтрШаблон("%1.%2", ЧастиЗначения[0], ЧастиЗначения[1]);
		Результат.Значение = Сред(Значение, СтрДлина(Результат.ПредставлениеТипа) + Сдвиг);
		Результат.ЭтоТипизированнаяСтрока = Истина;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Определяет тип значения по его текстовому представлению.
// Поддерживает как примитивные типы, так и ссылочные типы метаданных.
//
// Параметры:
//   ПредставлениеТипа - Строка - Текстовое представление типа (например, "Catalog.Контрагенты", "string")
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//
// Возвращаемое значение:
//   Тип, Неопределено - Тип значения или Неопределено, если тип не удалось определить
//
Функция ТипЗначенияПоПредставлению(ПредставлениеТипа, СтатусОбработкиЗапроса) Экспорт
	
	ОписаниеТипаМетаданных = РатМетаданные.ТипМетаданных(ПредставлениеТипа);
	КлассОшибки = РатОбщий.КлассыОшибок().Десериализация;
	
	ТипЗначения = Неопределено;
	
	Если ОписаниеТипаМетаданных <> Неопределено Тогда
		
		Попытка
			ТипЗначения = Тип(СтрШаблон("%1Ссылка.%2", ОписаниеТипаМетаданных.Имя, СтрРазделить(ПредставлениеТипа, ".")[1]));
		Исключение
			ТекстОшибки = РатОбщийКлиентСервер.ТекстОшибки(ИнформацияОбОшибке(),
				"Не удалось определить тип по Представлению " + ПредставлениеТипа);
			РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассОшибки, ТекстОшибки);
		КонецПопытки;
		
	Иначе
		
		ТипЗначения = РатТипыДанных.ТипПоПредставлению(ПредставлениеТипа);
		
	КонецЕсли;
	
	Если ТипЗначения = Неопределено Тогда
		
		ТекстОшибки = РатОбщийКлиентСервер.ТекстОшибки(ИнформацияОбОшибке(), "Не удалось определить тип по Представлению " + ПредставлениеТипа);
		РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассОшибки, ТекстОшибки);
		
	КонецЕсли;
		
	Возврат ТипЗначения;
	
КонецФункции

// Возвращает структуру с параметрами для десериализации значения.
// Анализирует переданное значение и ожидаемый тип, определяя способ десериализации.
//
// Параметры:
//   Значение - Произвольный - Значение для десериализации
//   ОжидаемыйТипЗначения - Тип, ОписаниеТипов, Неопределено - Ожидаемый тип результата десериализации
//
// Возвращаемое значение:
//   Структура - Параметры десериализации:
//     * ОграничениеТипа - ОписаниеТипов, Неопределено - Ограничение типа для десериализации
//     * ОжидаемыйТип - Тип, Неопределено - Ожидаемый тип результата
//     * ЭтоСоставнойТип - Булево - Признак составного типа
//     * ПереданноеЗначение - Произвольный - Исходное значение до обработки
//     * Значение - Произвольный - Значение после извлечения типа
//     * ТипЗначения - Тип - Тип извлеченного значения
//     * ПредставлениеТипа - Строка, Неопределено - Текстовое представление типа
//     * ЭтоТипизированнаяСтрока - Булево - Признак типизированной строки
//     * ЭтоВыражение - Булево - Признак выражения для вычисления
//
Функция ПараметрыДесериализации(Значение, ОжидаемыйТипЗначения) Экспорт
	
	ПараметрыДесериализации = Новый Структура("ОграничениеТипа, ОжидаемыйТип, ЭтоСоставнойТип");
	ПараметрыДесериализации.Вставить("ПереданноеЗначение", Значение);
	ПараметрыДесериализации.Вставить("ЭтоВыражение", Ложь);
	
	Если ТипЗнч(ОжидаемыйТипЗначения) = Тип("Тип") Тогда
		
		ПараметрыДесериализации.ОграничениеТипа = Новый ОписаниеТипов(РатКоллекции.ЗначениеВМассиве(ОжидаемыйТипЗначения));
		ПараметрыДесериализации.ОжидаемыйТип = ОжидаемыйТипЗначения;
		ПараметрыДесериализации.ЭтоСоставнойТип = Ложь;
		
	ИначеЕсли ТипЗнч(ОжидаемыйТипЗначения) = Тип("ОписаниеТипов") Тогда
		
		ПараметрыДесериализации.ОграничениеТипа = ОжидаемыйТипЗначения;
		КоличествоТипов = ОжидаемыйТипЗначения.Типы().Количество();
		ПараметрыДесериализации.ЭтоСоставнойТип = КоличествоТипов > 1;
		
		Если КоличествоТипов = 0 Тогда
			ПараметрыДесериализации.ОжидаемыйТип = Тип("Неопределено");
		ИначеЕсли КоличествоТипов = 1 Тогда
			ПараметрыДесериализации.ОжидаемыйТип = ОжидаемыйТипЗначения.Типы()[0];
		КонецЕсли;
		
	КонецЕсли;
	
	ТипИЗначение = ИзвлечьТипИЗначение(Значение);
	
	ПараметрыДесериализации.Вставить("Значение", ТипИЗначение.Значение);
	ПараметрыДесериализации.Вставить("ТипЗначения", ТипЗнч(ПараметрыДесериализации.Значение));
	ПараметрыДесериализации.Вставить("ПредставлениеТипа", ТипИЗначение.ПредставлениеТипа);
	
	ПараметрыДесериализации.Вставить("ЭтоТипизированнаяСтрока", ТипИЗначение.ЭтоТипизированнаяСтрока);
	
	Префикс = "Вычислить";
	Если ПустаяСтрока(ТипИЗначение.ПредставлениеТипа)
		И СтрНачинаетсяС(ПараметрыДесериализации.Значение, Префикс + "(")
		И СтрЗаканчиваетсяНа(ПараметрыДесериализации.Значение, ")") Тогда
		ПараметрыДесериализации.ЭтоВыражение = Истина;
		Сдвиг = СтрДлина(Префикс) + 2;
		ПараметрыДесериализации.Значение = Сред(ПараметрыДесериализации.Значение, Сдвиг, СтрДлина(ПараметрыДесериализации.Значение) - Сдвиг);
	КонецЕсли;
	
	//@skip-check constructor-function-return-section
	Возврат ПараметрыДесериализации;
	
КонецФункции

#КонецОбласти

#Область Десериализация

// Десериализует типизированное значение в объект 1С соответствующего типа.
// Типизированное значение может быть представлено в виде:
//   - Структуры с полями type и (id или value)
//   - Строки с префиксом типа (например, "Catalog.Контрагенты.УИД")
//
// Параметры:
//   Значение - Произвольный - Типизированное значение для десериализации
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//   ПараметрыДесериализации - Неопределено - Если не указаны, будут определены автоматически
//                           - см. ПараметрыДесериализации
//
// Возвращаемое значение:
//   Произвольный - Десериализованное значение соответствующего типа
//
Функция ДесериализоватьТипизированноеЗначение(Знач Значение, Знач СтатусОбработкиЗапроса, Знач ПараметрыДесериализации = Неопределено) Экспорт
	
	Если ПараметрыДесериализации = Неопределено Тогда
		ПараметрыДесериализации = ПараметрыДесериализации(Значение, Неопределено);
	КонецЕсли;
	
	КлассыОшибок = РатОбщий.КлассыОшибок();
	
	Если НЕ ЗначениеЗаполнено(ПараметрыДесериализации.ПредставлениеТипа) Тогда
		РатОбщий.ЗафиксироватьОшибку(СтатусОбработкиЗапроса, КлассыОшибок.РазборПараметровЗапроса, "Значение не содержит описание типа");
		ОжидаемыйТип = Неопределено;
	Иначе
		ОжидаемыйТип = ТипЗначенияПоПредставлению(ПараметрыДесериализации.ПредставлениеТипа, СтатусОбработкиЗапроса);
	КонецЕсли;
	
	Если ОжидаемыйТип = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Неопределено;
	
	// Используем основной модуль преобразований для десериализации
	// Передаем дополнительный параметр настроек как Неопределено для совместимости сигнатур
	Результат = РатПреобразования.ДесериализоватьЗначение(
		ПараметрыДесериализации.Значение,
		ОжидаемыйТип,
		СтатусОбработкиЗапроса,
		Неопределено); // TODO Неопределено как заглушка, проверить корректность подхода
	
	Возврат Результат;
	
КонецФункции

// Десериализует произвольное значение, автоматически определяя его тип.
// Поддерживает рекурсивную десериализацию вложенных структур и массивов.
//
// Параметры:
//   Значение - Произвольный - Значение для десериализации
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//
// Возвращаемое значение:
//   Произвольный - Десериализованное значение
//
Функция ДесериализоватьПроизвольноеЗначение(Значение, СтатусОбработкиЗапроса) Экспорт
	
	Результат = Значение;
	
	Если РатПреобразованияКлиентСервер.ЭтоТипизированноеЗначение(Значение) Тогда
		
		Результат = ДесериализоватьТипизированноеЗначение(Значение, СтатусОбработкиЗапроса);
		
	ИначеЕсли РатТипыДанных.ЭтоСтруктура(Значение) Тогда
		
		Результат = РатПреобразованияКоллекции.ДесериализоватьСтруктуру(Значение, СтатусОбработкиЗапроса);
		
	ИначеЕсли РатТипыДанных.ЭтоМассив(Значение) Тогда
		
		Результат = РатПреобразованияКоллекции.ДесериализоватьМассив(Значение, СтатусОбработкиЗапроса);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ЗагрузкаДанных

// Загружает таблицу значений из текстового документа в формате Markdown.
// Первая строка таблицы должна содержать заголовки колонок, вторая - разделитель.
//
// Параметры:
//   ТекстовыйДокумент - ТекстовыйДокумент - Текстовый документ с таблицей в формате Markdown
//   СтрокаНачало - Число - Номер строки, с которой начинается таблица (по умолчанию 1)
//
// Возвращаемое значение:
//   ТаблицаЗначений - Загруженная таблица, колонки соответствуют заголовкам из Markdown, тип колонок - Строка
//
Функция ЗагрузитьТаблицуMarkDown(ТекстовыйДокумент, СтрокаНачало = 1) Экспорт
	
	ЗагрузилиЗаголовок = Ложь;
	Результат = Новый ТаблицаЗначений();
	
	Разделитель = "|";
	
	Для НомерСтроки = СтрокаНачало По ТекстовыйДокумент.КоличествоСтрок() Цикл
		
		Строка = ТекстовыйДокумент.ПолучитьСтроку(НомерСтроки);
		Если НЕ СтрНачинаетсяС(Строка, Разделитель) Тогда
			Если ЗагрузилиЗаголовок Тогда
				Прервать;
			Иначе
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Блоки = СтрРазделить(Строка, Разделитель);
		
		Если ЗагрузилиЗаголовок Тогда
			СтрокаРезультата = Результат.Добавить();
			Для Инд = 1 По Блоки.ВГраница() - 1 Цикл
				СтрокаРезультата[Инд - 1] = СокрЛП(Блоки[Инд]);
			КонецЦикла;
		Иначе
			Для Инд = 1 По Блоки.ВГраница() - 1 Цикл
				Результат.Колонки.Добавить(СокрЛП(Блоки[Инд]), Новый ОписаниеТипов("Строка"));
			КонецЦикла;
			
			НомерСтроки = НомерСтроки + 1; // Пропуск строки разделителя
			ЗагрузилиЗаголовок = Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

// Преобразует значение согласно описанию реквизита.
//
// Параметры:
//   СыроеЗначение - Произвольный - исходное значение для преобразования
//   ОписаниеРеквизита - см. РатПреобразования.ОписаниеРеквизита
//   СтатусОбработкиЗапроса - см. РатОбщий.НовыйСтатусОбработкиЗапроса
//   Описание - Строка - описание операции для логирования
//
// Возвращаемое значение:
//   Произвольный - преобразованное значение
//
Функция ПреобразованноеЗначение(СыроеЗначение, ОписаниеРеквизита, СтатусОбработкиЗапроса, Описание) Экспорт
	
	ТипСтруктура = Тип("Структура");
	ТипМассив = Тип("Массив");
	
	Если ОписаниеРеквизита.Тип = ТипСтруктура Тогда
		Значение = РатПреобразования.ПреобразоватьДанные(СыроеЗначение, ОписаниеРеквизита.ВложенныеРеквизиты, СтатусОбработкиЗапроса, Описание);
	ИначеЕсли ОписаниеРеквизита.Тип = ТипМассив Тогда
		Значение = РатПреобразованияКоллекции.ПреобразоватьМассивДанных(СыроеЗначение, ОписаниеРеквизита, СтатусОбработкиЗапроса, Описание);
	Иначе
		Значение = РатПреобразования.ДесериализоватьЗначение(СыроеЗначение, ОписаниеРеквизита.Тип, СтатусОбработкиЗапроса, Описание);
	КонецЕсли;
	
	Возврат Значение;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции
// Проверяет, может ли строка быть идентификатором (имя переменной, свойства и т.д.).
// Идентификатор может содержать только буквы, цифры и (опционально) подчеркивание.
//
// Параметры:
//   Строка - Строка - Проверяемая строка
//   ВозможноПодчеркивание - Булево - Если Истина, допускается символ подчеркивания
//
// Возвращаемое значение:
//   Булево - Истина, если строка может быть идентификатором
//
Функция СтрокаМожетБытьИдентификатором(Строка, ВозможноПодчеркивание = Ложь)
	
	Если Лев(Строка, 1) <= "9" Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ДопустимыеСимволы = РатСтроки.НаборСимволов(Истина, Истина, Истина, Ложь);
	Если ВозможноПодчеркивание Тогда
		ДопустимыеСимволы = ДопустимыеСимволы + "_";
	КонецЕсли;
	
	Возврат ЗначениеЗаполнено(Строка)
		И СтрРазделить(ВРег(Строка), ВРег(ДопустимыеСимволы), Истина).Количество() = СтрДлина(Строка) + 1;
	
КонецФункции

#КонецОбласти
